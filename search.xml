<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>fastchat</title>
      <link href="//9b5a25d2.html"/>
      <url>//9b5a25d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="faschat基本知识"><a href="#faschat基本知识" class="headerlink" title="faschat基本知识"></a>faschat基本知识</h1><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="https://img-blog.csdnimg.cn/5ab46c6f52c04f45acbd215619533444.png" alt="img"></p><p>安装git lft</p><pre><code>sudo apt-get updatesudo apt-get install git-lfs</code></pre><p><strong>端口映射：</strong><code>ssh -CNg -L 7860:0.0.0.0:7860 root@ssh.intern-ai.org.cn -p 37723</code></p><p><strong>检查端口占用情况</strong>：</p><pre><code>安装 apt-get update安装lsof apt-get install lsof安装 apt-get install net-tools查看 lsof -i :21001删除进程 kill -9 进程PID #9的意思是强制删除pip install fschat==0.2.35</code></pre><h2 id="Fastapi基础知识"><a href="#Fastapi基础知识" class="headerlink" title="Fastapi基础知识"></a>Fastapi基础知识</h2><ol><li><p><strong>启动fastapi</strong>：<code>uvicorn spark_api:app</code></p></li><li><p><strong>发送post请求代码</strong></p></li></ol><p>命令行实现：<code>*curl -X POST &quot;http://127.0.0.1:8000/hello&quot; -H &quot;Content-Type: application/json&quot; -d &quot;&#123;&quot;name&quot;: &quot;John&quot;&#125;&quot;*</code></p><p>代码实现：</p><pre><code class="lang-python">import requestsimport jsondata = &#123;&quot;name&quot;: &quot;John&quot;&#125;headers = &#123;&#39;Content-Type&#39;: &#39;application/json&#39;&#125;response = requests.post(&#39;http://127.0.0.1:8000/hello&#39;, headers=headers, data=json.dumps(data))if response.status_code == 200:    print(f&quot;Response: &#123;response.json()&#125;&quot;)else:    print(f&quot;Error: &#123;response.status_code&#125;, &#123;response.text&#125;&quot;)</code></pre><h2 id="fastchat使用教程"><a href="#fastchat使用教程" class="headerlink" title="fastchat使用教程"></a>fastchat使用教程</h2><hr><pre><code class="lang-python">安装`pip3 install &quot;fschat[model_worker,webui]&quot;`加载大模型推理 python -m fastchat.serve.cli --model-path /你的下载路径/chatglm2-6blinux:python -m fastchat.serve.cli --model-path /root/LangChain-ChatGLM-Webui/model/chatglm2-6bwindows: python -m fastchat.serve.cli --model-path D:\project\LangChain-ChatGLM-Webui\model\chatglm2-6b</code></pre><p><img src="/Users\cassi\AppData\Roaming\Typora\typora-user-images\image-20240312095735966.png" alt="image-20240312095735966"></p><h3 id="web实现"><a href="#web实现" class="headerlink" title="web实现"></a>web实现</h3><hr><p>服务器ip <code>ifconfig</code>192.168.230.219</p><h1 id="首先启动-controller-："><a href="#首先启动-controller-：" class="headerlink" title="首先启动 controller ："></a>首先启动 controller ：</h1><pre><code>python3 -m fastchat.serve.controller --host 192.168.230.219 --port 21001python -m fastchat.serve.controller --host 0.0.0.0</code></pre><h1 id="然后启动模型：-说明，必须是本地ip"><a href="#然后启动模型：-说明，必须是本地ip" class="headerlink" title="然后启动模型： 说明，必须是本地ip"></a>然后启动模型： 说明，必须是本地ip</h1><pre><code>python3 -m fastchat.serve.model_worker --load-8bit --model-names chatglm2-6b --model-path /data/models/chatglm3-6b-models --controller-address http://192.168.230.219:21001 --worker-address http://192.168.230.219:8080 --host 0.0.0.0 --port 8080 windows:python -m fastchat.serve.model_worker --model-path /root/LangChain-ChatGLM-Webui/model/chatglm2-6b --host 0.0.0.0 linux:python -m fastchat.serve.model_worker --model-path D:\project\LangChain-ChatGLM-Webui\model\chatglm2-6b --host 0.0.0.0  --load-4bit</code></pre><h1 id="最后启动-openapi的-兼容服务-地址-8000"><a href="#最后启动-openapi的-兼容服务-地址-8000" class="headerlink" title="最后启动 openapi的 兼容服务 地址 8000"></a>最后启动 openapi的 兼容服务 地址 8000</h1><pre><code>python3 -m fastchat.serve.openai_api_server --controller-address http://172.17.0.2:21001 --host 0.0.0.0 --port 8000python -m fastchat.serve.openai_api_server --host 0.0.0.0</code></pre><h1 id="gradio服务"><a href="#gradio服务" class="headerlink" title="gradio服务"></a>gradio服务</h1><pre><code>linux:python -m fastchat.serve.gradio_web_server --host 0.0.0.0windows:python -m fastchat.serve.gradio_web_server</code></pre><p>服务默认端口是 7860，可以通过<code>--port</code>参数来修改端口，还可以通过添加<code>--share</code>参数来开启 Gradio 的共享模式，这样就可以通过外网访问 WebUI 服务</p><pre><code>gradio==4.10 fschat==0.2.35 pydantic==2.5.2 fastapi==0.109.0 langchain==0.0.354 pydantic==1.10.13  openai==1.9.0</code></pre><p>fastchat原理：<a href="https://blog.csdn.net/qq_35082030/article/details/133174714?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-4-133174714-blog-130027299.235^v43^pc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">使用FastChat部署Baichuan2_fastchat教程-CSDN博客</a> <a href="https://blog.csdn.net/qiaotl/article/details/132765010?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-132765010-blog-135302417.235^v43^pc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">FastChat工作原理解析-CSDN博客</a></p><p>fastchat部署过程：<a href="https://blog.csdn.net/qq128252/article/details/132759107?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-132759107-blog-135302417.235^v43^pc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">Fastchat：基于fastapi构建大模型加载服务-CSDN博客</a><a href="https://blog.csdn.net/2301_78285120/article/details/135302417?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-135302417-blog-130996123.235^v43^pc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-135302417-blog-130996123.235^v43^pc_blog_bottom_relevance_base5&amp;utm_relevant_index=6">用通俗易懂的方式讲解大模型：使用 FastChat 部署 LLM 的体验太爽了-CSDN博客</a></p><p><a href="https://blog.csdn.net/huiguo_/article/details/135766850?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-135766850-blog-130996123.235^v43^pc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-135766850-blog-130996123.235^v43^pc_blog_bottom_relevance_base5&amp;utm_relevant_index=5">本地化部署大模型方案二：fastchat+llm(vllm)_fastchat本地化部署大模型-CSDN博客</a></p><p>fastchat的yuan部署:<a href="https://blog.csdn.net/2401_82700030/article/details/135976153?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-135976153-blog-130996123.235^v43^pc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8">Yuan2.0完成FastChat框架适配，内置模板实现多轮对话_yuanchat-CSDN博客</a></p><p>fastchat各家模型:<a href="https://blog.csdn.net/studyeboy/article/details/132800291?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-132800291-blog-132765010.235^v43^pc_blog_bottom_relevance_base5&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=9">FastChat_fastchat qwen-CSDN博客</a></p><p>本地知识库:<a href="https://blog.csdn.net/sj5590155/article/details/131720160?spm=1000.2115.3001.6382&amp;utm_medium=distribute.pc_feed_v2.none-task-blog-search_records_recommend-6-131720160-null-null.329^v9^个推pc首页推荐—桶9&amp;depth_1-utm_source=distribute.pc_feed_v2.none-task-blog-search_records_recommend-6-131720160-null-null.329^v9^个推pc首页推荐—桶9">LangChain + ChatGLM2-6B 搭建个人专属知识库_langchain chatglm-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> fastchat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//0.html"/>
      <url>//0.html</url>
      
        <content type="html"><![CDATA[<p>当然可以，以下是根据您提供的招聘要求制作的表格：</p><div class="table-container"><table><thead><tr><th>招聘要求</th><th>描述</th></tr></thead><tbody><tr><td>个人基本信息</td><td>- 学历：计算机科学硕士或相关领域<br>- 沟通能力：良好的沟通能力<br>- 语言能力：流利的中文和英文沟通能力</td></tr><tr><td>教育背景</td><td>- 学历要求：985高校或211工程院校的学历将被优先考虑<br>- 相关课程：数据结构、算法</td></tr><tr><td>项目经验</td><td>- 项目经验：多年的项目开发经验，特别是在Web开发和数据分析领域<br>- 独立项目能力：能够独立完成项目，并能够按时交付<br>- Web开发经验：具备丰富的Web开发经验，包括前端和后端开发，熟悉常用的Web开发框架和技术<br>- 数据分析经验：具备数据分析项目经验，能够处理大规模数据集，进行数据清洗、分析和可视化<br>- 团队协作经验：具有良好的团队协作经验，能够与不同背景和职能的团队成员协调合作，达成共同目标<br>- 问题解决能力：具备解决复杂技术问题的能力，能够快速识别和解决挑战<br>- 项目作品集：可以提供项目作品集，展示过去项目的成功经验和成果</td></tr><tr><td>技术技能</td><td>- 编程语言：熟练掌握Python、Java等编程语言<br>- 开发框架：熟悉Spring、Django等常用开发框架<br>- 数据库管理：熟悉数据库管理，包括设计、优化和维护数据库<br>- 其他认证：具备AWS Certified Developer或Scrum Master等相关认证者优先考虑<br>- 云计算和容器化技术：熟悉云计算和容器化技术，有相关认证者优先<br>- 机器学习和深度学习：具备机器学习或深度学习经验者优先</td></tr><tr><td>其他要求</td><td>- 大规模系统设计经验：具备大规模系统设计和开发经验，能够独立领导项目<br>- 跨文化团队合作经验：具备跨文化团队合作经验，能够有效沟通和解决问题</td></tr><tr><td>工作经验</td><td>- 互联网行业工作经验：至少3年的互联网行业工作经验，包括前端和后端开发</td></tr></tbody></table></div><p>这个表格涵盖了您提供的所有招聘要求，希望对您有所帮助。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言总复习</title>
      <link href="//39d974b0.html"/>
      <url>//39d974b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="章节复习"><a href="#章节复习" class="headerlink" title="章节复习"></a>章节复习</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="最简单的程序"><a href="#最简单的程序" class="headerlink" title="最简单的程序"></a>最简单的程序</h3><pre><code class="lang-c">#include &lt;stdio.h&gt;  /*文件包含*/int main ( )  /*主函数 */&#123;                                  printf (&quot;This is a C program.\n&quot;); return 0; //当main函数执行结束前将整数0作为函数值&#125;</code></pre><p>说明： main-主函数名， void-函数类型</p><p>• 每个C程序必须有一个主函数main</p><p>• { }是函数开始和结束的标志，不可省</p><p>• 每个C语句以分号结束</p><p>• 使用标准库函数时应在程序开头一行写：</p><p>#include <stdio.h></stdio.h></p><h3 id="华氏温度到摄氏温度"><a href="#华氏温度到摄氏温度" class="headerlink" title="华氏温度到摄氏温度"></a>华氏温度到摄氏温度</h3><pre><code>#include &lt;stdio.h&gt;int main ( )&#123;float f, c;//定义f和c为单精度浮点型变量f=32;//确定f的值c=(5.0/9)\*(f-32);//利用公式计算c的值printf(&quot;f=%f\nc=%f\n&quot;, f, c);//按行输出f和c的值return 0;&#125;</code></pre><h3 id="鸡兔同笼问题"><a href="#鸡兔同笼问题" class="headerlink" title="鸡兔同笼问题"></a>鸡兔同笼问题</h3><pre><code>#include&lt;stdio.h&gt;//引入头文件void main( )&#123;//主函数int x, y, a, b;//声明4个整型变量printf(&quot;Please input total head number (x) and** total foot number (y):\n&quot;);scanf(&quot;%d%d&quot;, &amp;x, &amp;y);//输入数据b=(y-2\*x)/2; a=x-b;printf(&quot;鸡:%3d兔:%3d\n&quot; , a, b);//输出结果&#125;</code></pre><h2 id="第二章-程序设计基础"><a href="#第二章-程序设计基础" class="headerlink" title="第二章  程序设计基础"></a>第二章  程序设计基础</h2><h3 id="宏定义的方法"><a href="#宏定义的方法" class="headerlink" title="宏定义的方法"></a>宏定义的方法</h3><blockquote><ul><li>不带参数的宏定义： #define 宏名 宏体  <code>#define PI 3.1416</code></li><li>带参数的宏定义： #define 宏名（参数表） 宏体  <code>define MAX(x,y)  x&gt;y?x:y</code></li><li>终止宏定义的作用域：#undef（宏名） `#undef(PI)<h3 id="c运算符以及优先级"><a href="#c运算符以及优先级" class="headerlink" title="c运算符以及优先级"></a>c运算符以及优先级</h3></li></ul></blockquote><h3 id="程序设计基本技术"><a href="#程序设计基本技术" class="headerlink" title="程序设计基本技术"></a>程序设计基本技术</h3><h2 id="第三章-数据组织与处理基础"><a href="#第三章-数据组织与处理基础" class="headerlink" title="第三章 数据组织与处理基础"></a>第三章 数据组织与处理基础</h2><p><strong>数据类型与计算机系统结构密不可分</strong></p><p>✓ <strong>16、32位编译器：int、short型变量分配2个字节空间</strong></p><p>✓ <strong>64位编译器：int型变量分配4个字节空间，short2个字节</strong></p><pre><code>#include&lt;stdio.h&gt;void main( ) &#123;short int a=32767, b;b=a+1;printf(&quot;a=%d b=%d\n&quot;, a, b);&#125;</code></pre><p>转义字符<br><img src="/image-20231118151708113.png" alt="image-20231118151708113"></p><p><img src="/image-20231118151953055.png" alt="image-20231118151953055"></p><p><img src="/image-20231118152040555.png" alt="image-20231118152040555"></p><p><strong>用%m.nf指定数据宽度和小数位数</strong></p><p><strong>printf(“%15.13f\n”, a/7);</strong></p><p><img src="/image-20231118152226077.png" alt="image-20231118152226077"></p><p><strong>例：将一任意十进制数转换成三进制并输出</strong></p><pre><code>#include&lt;stdio.h&gt;int main( ) &#123;  int i=0, x, d[20];  scanf(&quot;%d&quot;, &amp;x);  while(x&gt;0) &#123;    d[i++]=x%3;    x=x/3;  &#125;for(i--; i&gt;=0; i--) printf(&quot;%d&quot;, d[i]);printf(&quot;\n&quot;); return 0;&#125;结果：491211</code></pre><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>实现代码：</p><pre><code>#include &lt;stdio.h&gt;struct Stu &#123; long int num; char name[20];char sex;int age;float score;char addr[20];&#125;student=&#123;10001,&quot;张三&quot;,&#39;M&#39;, 19, 586, &quot;北京市朝阳区&quot;&#125;;</code></pre><p>调取数据：</p><pre><code>int main( )&#123; printf(&quot;NO.:%ld\nName:%s\nSex:%c\nAge:%d\nScore:%f\nAddress:%s\n&quot;, student.num,student.name, student.sex, student.age, student.score, student.addr);return 0;&#125;</code></pre><p>实现效果：</p><p><img src="/image-20231118153127167.png" alt="image-20231118153127167"></p><h3 id="C语言对外部数据的组织和处理"><a href="#C语言对外部数据的组织和处理" class="headerlink" title="C语言对外部数据的组织和处理"></a><strong>C语言对外部数据的组织和处理</strong></h3><pre><code>#include &lt;stdio.h&gt;  #include&lt;stdlib.h&gt;  int main( )   &#123;       FILE *fp;       char ch;      // 写入文件      if((fp=fopen(&quot;f:/CAI/C/tmp/myfile.dat&quot;,&quot;w&quot;))==NULL)       &#123;           printf(&quot;打开文件失败\n&quot;);           exit(0);       &#125;      while((ch=getchar())!=&#39;@&#39;) fputc(ch, fp);       fclose(fp);      // 从文件中读取并打印内容      if((fp=fopen(&quot;f:/CAI/C/tmp/myfile.dat&quot;,&quot;r&quot;))==NULL)       &#123;           printf(&quot;打开文件失败\n&quot;);           exit(0);       &#125;      while((ch=fgetc(fp))!=EOF) putchar(ch);       printf(&quot;\n&quot;);      fclose(fp);      return 0;  &#125;</code></pre><p><img src="/image-20231118153523828.png" alt="image-20231118153523828"></p><h2 id="第四章-结构化程序设计"><a href="#第四章-结构化程序设计" class="headerlink" title="第四章 结构化程序设计"></a>第四章 结构化程序设计</h2><h3 id="结构化程序设计方法"><a href="#结构化程序设计方法" class="headerlink" title="结构化程序设计方法"></a>结构化程序设计方法</h3><h4 id="结构化程序设计思想"><a href="#结构化程序设计思想" class="headerlink" title="结构化程序设计思想"></a>结构化程序设计思想</h4><p>分而治之 自顶向下、逐步求精<br>模块化设计 结构化编码</p><h4 id="结构化程序的流程控制语句"><a href="#结构化程序的流程控制语句" class="headerlink" title="结构化程序的流程控制语句"></a>结构化程序的流程控制语句</h4><p>✓ <strong>break语句</strong>：提前结束整个循环，接下来执行循环之后的语句（注：<strong>break</strong>语句只能于switch语句和循环结构中）</p><p>✓ <strong>continue语句</strong>：提前结束本次循环，接着进行下一次循环的判断，如满足循环条件，继续循环</p><p>✓ <strong>goto语句</strong>：无条件转向语句</p><p><code>break</code>:</p><p><img src="/image-20231118154354507.png" alt="image-20231118154354507"></p><p><code>continue</code>:</p><p><img src="/image-20231118154519716.png" alt="image-20231118154519716"></p><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>实现代码：</p><pre><code>#include&quot;stdio.h&quot;int main( )&#123;int x, y, p, q;printf(&quot; Please input the total boats (p) and People (q):&quot;);scanf(“%d%d”, &amp;p, &amp;q); // 输入船数和人数x=(q-4*p)/2; // 大船数y=p-x; // 小船数printf(&quot; The number of big boats is %d.\n The number of small boats is %d.\n&quot;, x, y);return 0;&#125;</code></pre><p>实现效果：</p><p><img src="/image-20231118154720844.png" alt="image-20231118154720844"></p><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><p><img src="/image-20231118154945701.png" alt="image-20231118154945701"></p><p><img src="/image-20231118155003875.png" alt="image-20231118155003875"></p><p>代码：</p><pre><code>#include &quot;stdio.h&quot;  int main() &#123;      int week, num;      int flag = 0; // flag初始化为0      printf(&quot;请输入今天是周几(1～7)、您的车牌尾号(0～9):&quot;);      scanf(&quot;%d%d&quot;, &amp;week, &amp;num); // 输入时间和车牌尾号      switch (num) &#123;          case 0:          case 1:              if (week == 1) &#123;                  flag = 1;              &#125;              break;          case 2:          case 6:              if (week == 2) &#123;                  flag = 1;              &#125;              break;          case 3:          case 7:              if (week == 3) &#123;                  flag = 1;              &#125;              break;          case 4:          case 8:              if (week == 4) &#123;                  flag = 1;              &#125;              break;          case 5:          case 9:              if (week == 5) &#123;                  flag = 1;              &#125;              break;          default: // 如果车牌尾号不在0-9之间，输出错误信息并退出程序              printf(&quot;您输入的车牌尾号不正确！\n&quot;);              return -1; // 或者使用return语句返回一个错误码，以表示程序异常退出。例如：return -1;      &#125;      if (flag == 1) &#123; // 根据flag的值输出车辆限行信息或不限行信息          printf(&quot;对不起，您的车辆今天限行！\n&quot;);      &#125; else &#123;          printf(&quot;恭喜您，您的车辆今天不限行！\n&quot;);      &#125;      return 0; // 表示程序正常退出。也可以使用return语句返回一个整数值表示程序的退出状态。例如：return 0; // 表示程序正常退出。return -1; // 表示程序异常退出。</code></pre><p>运行结果:</p><p><img src="/image-20231118155206485.png" alt="image-20231118155206485"></p><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><img src="/image-20231118155318861.png" alt="image-20231118155318861"><br>while应用例子<br><img src="/image-20231118155706206.png" alt="image-20231118155706206"></p><p><code>do-while循环</code></p><p><img src="/image-20231118155723356.png" alt="image-20231118155723356"></p><p><img src="/image-20231118155744083.png" alt="image-20231118155744083"></p><p><code>for 循环</code><br><img src="/image-20231118155909146.png" alt="image-20231118155909146"></p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p><img src="/image-20231118160034225.png" alt="image-20231118160034225"></p>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c#学习日志1</title>
      <link href="//91987568.html"/>
      <url>//91987568.html</url>
      
        <content type="html"><![CDATA[<h1 id="static-与-public"><a href="#static-与-public" class="headerlink" title="static 与 public"></a>static 与 public</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="static介绍"><a href="#static介绍" class="headerlink" title="static介绍"></a>static介绍</h3><p>在C#中，<code>static</code> 是一个修饰符，用于声明静态成员，包括静态方法、静态字段和静态属性等。静态成员属于类而不是类的实例，因此可以通过类名直接访问，而不需要创建类的实例。与之相对，非静态成员则是实例成员，必须通过类的实例才能访问。</p><p>在这个特定的方法 <code>ConvertObjectListToFloatList</code> 中，使用 <code>static</code> 的原因可能是因为这个方法在整个类中是通用的，不依赖于特定的实例对象。这使得你可以通过类名来调用这个方法，而不需要先创建类的实例。例如：</p><pre><code>csharpCopy codeList&lt;object&gt; objectList = new List&lt;object&gt; &#123; 1, 2, 3, &quot;4&quot;, 5.5 &#125;;List&lt;float&gt; floatList = ClassName.ConvertObjectListToFloatList(objectList);</code></pre><p>如果该方法是实例方法而不是静态方法，你需要先创建类的实例，然后通过该实例调用方法：</p><pre><code>csharpCopy codeClassName instance = new ClassName();List&lt;float&gt; floatList = instance.ConvertObjectListToFloatList(objectList);</code></pre><p>因此，使用 <code>static</code> 主要取决于方法是否需要依赖于特定实例。如果不需要，可以考虑使用 <code>static</code> 使得方法更为通用和直接。</p><h3 id="static代码"><a href="#static代码" class="headerlink" title="static代码"></a>static代码</h3><p>代码：</p><pre><code>using System;// 定义一个名为 MathHelper 的类public class MathHelper&#123;    // 静态字段：表示 MathHelper 类的实例数量    public static int InstanceCount = 0;    // 静态方法：计算一个数字的平方    public static double Square(double number)    &#123;        return number * number;    &#125;    // 静态属性：一个私有的静态整数属性    private static int staticProperty;    public static int StaticProperty    &#123;        get &#123; return staticProperty; &#125;        set &#123; staticProperty = value; &#125;    &#125;    // 静态构造函数：在类第一次被使用时执行，且仅执行一次    static MathHelper()    &#123;        Console.WriteLine(&quot;Static constructor called.&quot;);    &#125;    // 实例构造函数：在每次创建类的新实例时执行    public MathHelper()    &#123;        // 每次创建新实例时，增加实例数量        InstanceCount++;    &#125;&#125;class Program&#123;    // 应用程序的入口点    static void Main()    &#123;        // 访问静态字段和方法        // 使用 MathHelper 类的静态方法计算 5 的平方        Console.WriteLine(&quot;Square of 5: &quot; + MathHelper.Square(5));        // 访问静态字段，显示 MathHelper 类的实例数量        Console.WriteLine(&quot;Instance count: &quot; + MathHelper.InstanceCount);        // 访问静态属性        // 设置 MathHelper 类的静态属性值        MathHelper.StaticProperty = 42;        // 获取并显示 MathHelper 类的静态属性值        Console.WriteLine(&quot;Static property value: &quot; + MathHelper.StaticProperty);        // 创建两个 MathHelper 类的实例        // 创建第一个实例        MathHelper obj1 = new MathHelper();        // 创建第二个实例        MathHelper obj2 = new MathHelper();        // 显示 MathHelper 类的实例数量        Console.WriteLine(&quot;Instance count after creating objects: &quot; + MathHelper.InstanceCount);        // 静态构造函数只会在第一次使用类时调用，这里只会输出一次    &#125;&#125;</code></pre><p>这个示例包括了一个 <code>MathHelper</code> 类，其中有静态字段、方法、属性以及构造函数。在 <code>Main</code> 方法中，我们演示了如何访问这些静态成员。请注意，静态构造函数只在第一次使用类时调用。运行这个程序，你会看到输出如下：</p><pre><code>Static constructor called.Square of 5: 25Instance count: 0Static property value: 42Instance count after creating objects: 2</code></pre><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p><code>public</code> 关键字是用于定义方法的访问修饰符之一。在这个特定的上下文中，<code>public</code> 表示这个方法是公开的，可以被其他类、对象或程序集访问。这是 C# 中的一种封装概念，有助于控制方法的可见性和访问权限。</p><p>在你提供的代码中，例如:</p><pre><code>public static float CalculateScoreVector(            List&lt;float&gt; X, List&lt;object&gt; tmpXObjCoe, int tmpXObjConstant, List&lt;object&gt; Y,             List&lt;object&gt; tmpYObjCoe, int tmpYObjConstant)&#123;    // 方法体&#125;</code></pre><p>这里 <code>public</code> 表示该方法是公开的，其他代码可以访问它。这对于该方法需要被外部调用的情况很重要。如果你希望其他类或程序集能够使用这个方法，就需要将它声明为 <code>public</code>。这样，其他类或程序集就可以通过类名直接调用这个方法。</p><p>相反，如果你将一个方法声明为 <code>private</code>，则该方法只能在包含它的类内部访问，其他类无法访问它。<code>private</code> 主要用于封装类的内部实现，防止外部直接访问类的内部细节。</p><p>所以，<code>public</code> 和 <code>static</code> 这两个关键字的作用是不同的。<code>public</code> 关键字指定了访问权限，而 <code>static</code> 关键字指定了成员是属于类而不是类的实例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flask</title>
      <link href="//36c70eb9.html"/>
      <url>//36c70eb9.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序（三）判断与循环</title>
      <link href="//e92a798c.html"/>
      <url>//e92a798c.html</url>
      
        <content type="html"><![CDATA[<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p><div class="table-container"><table><thead><tr><th style="text-align:left">语句</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">if 语句</td><td style="text-align:left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td style="text-align:left">if else语句</td><td style="text-align:left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr><tr><td style="text-align:left">嵌套if 语句</td><td style="text-align:left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td style="text-align:left">switch语句</td><td style="text-align:left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td style="text-align:left">嵌套switch语句</td><td style="text-align:left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr></tbody></table></div><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题(统计能整除数字的位数)</title>
      <link href="//cbc0886d.html"/>
      <url>//cbc0886d.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p><p>如果满足 <code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：num = 7输出：1解释：7 被自己整除，因此答案是 1 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：num = 121输出：2解释：121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：num = 1248输出：4解释：1248 可以被它每一位上的数字整除，因此答案是 4 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 109</code></li><li><code>num</code> 的数位中不含 <code>0</code></li></ul><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h2><p>代码实现：</p><pre><code>int countDigits(int num)&#123;    int t = num, res = 0;    while(t)&#123;        if (num % (t % 10) == 0) &#123;            res += 1;        &#125;        t /=10;    &#125;    return res;&#125;</code></pre><p>代码讲解：</p><ol><li>首先，定义了两个整数变量<code>t</code>和<code>res</code>，并将它们初始化为<code>num</code>和0。其中，<code>t</code>用于存储<code>num</code>的副本，而<code>res</code>用于存储满足条件的数字的数量。</li><li>然后，使用<code>while</code>循环来迭代<code>num</code>的每一位数字。在每次迭代中，执行以下操作：<ul><li>使用取模运算符（<code>%</code>）获取<code>num</code>的最后一位数字，并将其存储在变量<code>t % 10</code>中。</li><li>检查<code>num</code>是否可以被<code>t % 10</code>整除。如果可以整除，则将<code>res</code>的值加1。</li><li>使用除法运算符（<code>/</code>）将<code>t</code>除以10，以便在下一次迭代中处理下一位数字。</li></ul></li><li>当<code>t</code>变为0时，表示已经处理完<code>num</code>的所有位数。此时，循环结束。</li><li>最后，返回变量<code>res</code>的值，即满足条件的数字的数量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习日记 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫之豆瓣电影top250</title>
      <link href="//cd04f754.html"/>
      <url>//cd04f754.html</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫相关思路"><a href="#爬虫相关思路" class="headerlink" title="爬虫相关思路"></a>爬虫相关思路</h1><h2 id="爬虫网站"><a href="#爬虫网站" class="headerlink" title="爬虫网站"></a>爬虫网站</h2><pre><code>https://movie.douban.com/top250 #爬虫网站，豆瓣top250</code></pre><p>进入豆瓣电影<code>top250</code>官网，右键点击属性或者按键盘上<code>f12</code>进入属性页面</p><p><img src="/image-20231026160021114.png" alt="image-20231026160021114"></p><p>按照如下步骤获取<code>Cookies</code>，<code>url</code>，<code>user-agent</code>信息，这些信息主要是模拟访问网站:</p><ul><li>找到网络并点击进入</li><li>刷新网页得到访问内容</li><li>找到<code>top250</code>进入找到相关信息</li></ul><p><img src="/image-20231026160706387.png" alt="image-20231026160706387"></p><p>将如下数据封装成一个函数</p><pre><code>def Agent_info():    &#39;&#39;&#39;用于保存Cookies，url，user-agent信息&#39;&#39;&#39;    headers = &#123;        &#39;Cookie&#39;: &#39;ll=&quot;108296&quot;; bid=ql4eVea35OE; _pk_id.100001.4cf6=eb8ccbe690de15db.1697115364.; __yadk_uid=T6v0V74NMJ2y421xzxioww6xLN6VfPe2; _vwo_uuid_v2=D79406DF4AAE71A1C157704ED368E5A95|dbc5faa35b4a745a69d2f7cd7cd153ea; __utmz=30149280.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmz=223695111.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmc=30149280; __utmc=223695111; Hm_lvt_16a14f3002af32bf3a75dfe352478639=1697250066; Hm_lpvt_16a14f3002af32bf3a75dfe352478639=1697250066; ap_v=0,6.0; __utma=30149280.1219357050.1697115357.1697249765.1697261508.7; __utmb=30149280.0.10.1697261508; __utma=223695111.682780799.1697115364.1697249765.1697261508.7; __utmb=223695111.0.10.1697261508; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1697261508%2C%22https%3A%2F%2Fwww.douban.com%2F%22%5D; _pk_ses.100001.4cf6=1; dbcl2=&quot;262712933:vV08l1yT2sw&quot;; ck=AzYJ; push_noty_num=0; push_doumail_num=0&#39;,        &#39;Host&#39;: &#39;movie.douban.com&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36&#39;    &#125;    return headers</code></pre><ul><li>‘Cookie’: 包含网站的Cookie信息，用于维护用户会话状态。</li><li>‘Host’: 指定请求的主机（Host）地址，用于指明请求要发送到哪个服务器。</li><li>‘User-Agent’: 包含浏览器标识信息，用于伪装请求来模拟不同的浏览器。</li></ul><p>帮助伪装成浏览器并与目标网站进行通信，以获取所需的数据。</p><h2 id="爬取网站网页代码"><a href="#爬取网站网页代码" class="headerlink" title="爬取网站网页代码"></a>爬取网站网页代码</h2><h3 id="直接抓取代码"><a href="#直接抓取代码" class="headerlink" title="直接抓取代码"></a>直接抓取代码</h3><p>实现代码：</p><pre><code>import requestsdef Agent_info():    &#39;&#39;&#39;用于保存Cookies，url，user-agent信息&#39;&#39;&#39;    headers = &#123;        &#39;Cookie&#39;: &#39;ll=&quot;108296&quot;; bid=ql4eVea35OE; _pk_id.100001.4cf6=eb8ccbe690de15db.1697115364.; __yadk_uid=T6v0V74NMJ2y421xzxioww6xLN6VfPe2; _vwo_uuid_v2=D79406DF4AAE71A1C157704ED368E5A95|dbc5faa35b4a745a69d2f7cd7cd153ea; __utmz=30149280.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmz=223695111.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmc=30149280; __utmc=223695111; Hm_lvt_16a14f3002af32bf3a75dfe352478639=1697250066; Hm_lpvt_16a14f3002af32bf3a75dfe352478639=1697250066; ap_v=0,6.0; __utma=30149280.1219357050.1697115357.1697249765.1697261508.7; __utmb=30149280.0.10.1697261508; __utma=223695111.682780799.1697115364.1697249765.1697261508.7; __utmb=223695111.0.10.1697261508; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1697261508%2C%22https%3A%2F%2Fwww.douban.com%2F%22%5D; _pk_ses.100001.4cf6=1; dbcl2=&quot;262712933:vV08l1yT2sw&quot;; ck=AzYJ; push_noty_num=0; push_doumail_num=0&#39;,        &#39;Host&#39;: &#39;movie.douban.com&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36&#39;    &#125;    return headersdef get_url(url):    print(&quot;抓取网址:&quot;, url)    headers = Agent_info()    request = requests.get(url, headers=headers)    print(request.text)if __name__ == &#39;__main__&#39;:    print(&quot;开始抓取&quot;)    get_url(&quot;https://movie.douban.com/top250&quot;)</code></pre><p>代码效果：</p><p><img src="/image-20231026223327340.png" alt="image-20231026223327340"></p><h3 id="BeautifulSoup美化输出内容"><a href="#BeautifulSoup美化输出内容" class="headerlink" title="BeautifulSoup美化输出内容"></a>BeautifulSoup美化输出内容</h3><p>利用<code>BeautifulSoup</code>对输出格式进行美化，<code>BeautifulSoup</code>是一个Python库，用于解析HTML或XML文件，以便于从中提取数据。它是一个强大的解析器，能够省去编写正则表达式的繁琐工作。<code>BeautifulSoup</code>支持多种解析器，包括Python标准库中的HTML解析器以及第三方解析器如<code>lxml</code>。</p><p>使用<code>BeautifulSoup</code>，你可以方便地定位到HTML或XML文件中的特定标签，并从这些标签中提取出你需要的信息。此外，它提供了一些实用的功能，如查找和修改文档内容。</p><p>要使用<code>BeautifulSoup</code>，你首先需要导入这个模块：<code>from bs4 import beautifulsoup</code>。然后，你可以创建一个<code>BeautifulSoup</code>对象，指定你要解析的内容和使用的解析器：<code>soup = beautifulsoup(parse_content, &#39;parser&#39;)</code>。其中，<code>parse_content</code>是你要解析的内容，<code>&#39;parser&#39;</code>是你选择的解析器。</p><p>利用代码如下:</p><pre><code>def get_url(url):    print(&quot;抓取网址:&quot;, url)    headers = Agent_info()    request = requests.get(url, headers=headers)    soup = BeautifulSoup(request.text,&#39;lxml&#39;) # 美化显示的内容    pic = soup.find_all(attrs=&#123;&#39;class&#39;: &#39;pic&#39;&#125;)     film_urls = []    for x in pic:        href = x.a.get(&#39;href&#39;)        film_urls.append(href)    #遍历pic中的每个元素x，并从中提取href属性的值，将其添加到film_urls列表中    print(film_urls)    return film_urls</code></pre><p><strong>代码解释</strong>：</p><p><code>href = x.a.get(&#39;href&#39;)</code> 这行代码的意思是从HTML元素 <code>x.a</code> 中获取名为 ‘href’ 的属性值，并将其赋值给变量 <code>href</code>。</p><p>在这段代码中，<code>x</code> 是一个HTML元素对象，通常表示一个标签（如 <code>&lt;a&gt;</code>）。<code>x.a</code> 表示该元素的子元素 <code>&lt;a&gt;</code>。<code>get(&#39;href&#39;)</code> 是一个方法，用于获取指定属性的值。在这里，它获取的是 <code>&lt;a&gt;</code> 标签的 ‘href’ 属性值，这个值通常是一个URL链接。</p><p><strong>实现效果</strong>：</p><p><img src="/image-20231026225108797.png" alt="image-20231026225108797"></p><h2 id="抓取网页电影名称和电影地址"><a href="#抓取网页电影名称和电影地址" class="headerlink" title="抓取网页电影名称和电影地址"></a>抓取网页电影名称和电影地址</h2><p>实现代码:</p><pre><code>def get_url(url):    print(&quot;抓取网址：&quot;, url)  # 打印正在抓取的网址    headers = Agent_info()  # 获取请求头信息    request = requests.get(url, headers=headers)  # 发送GET请求，携带请求头信息    soup = BeautifulSoup(request.text, &#39;lxml&#39;)  # 使用BeautifulSoup解析网页内容    pic = soup.find_all(attrs=&#123;&#39;class&#39;: &#39;pic&#39;&#125;)  # 查找所有具有&#39;class&#39;: &#39;pic&#39;属性的元素    film_urls = []  # 电影详情地址列表    for x in pic:        href = x.a.get(&#39;href&#39;)  # 获取每个元素的a标签中的href属性值        film_urls.append(href)  # 将href属性值添加到电影详情地址列表中    movie_list = []  # 外国电影名字列表    div_list = soup.find_all(attrs=&#123;&#39;class&#39;: &#39;hd&#39;&#125;)  # 查找所有具有&#39;class&#39;: &#39;hd&#39;属性的元素    for each in div_list:        movie = each.a.contents[3].text.strip()  # 获取每个元素的a标签中的第三个子元素的文本内容，并去除首尾空格        movie = movie[2:]  # 从第三个字符开始取值        movie_list.append(movie)  # 将取到的值添加到外国电影名字列表中    return film_urls, movie_list  # 返回电影详情地址列表和外国电影名字列表</code></pre><h2 id="获取电影信息"><a href="#获取电影信息" class="headerlink" title="获取电影信息"></a>获取电影信息</h2><pre><code>def get_url_info(film_url, film_name_en, id):    print(&quot;抓取网址:&quot;, film_url)    headers = Agent_info()    request = requests.get(film_url, headers=headers)    soup = BeautifulSoup(request.text, &#39;lxml&#39;)    # 排名    ranks = soup.find(attrs=&#123;&#39;class&#39;: &#39;top250-no&#39;&#125;).text.split(&#39;.&#39;)[1]    # 电影名    film_name = soup.find(attrs=&#123;&quot;property&quot;: &quot;v:itemreviewed&quot;&#125;).text.split(&#39; &#39;)[0]    # 导演    director = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[1].split(&#39;:&#39;)[1].strip()    # 编剧    scriptwriter = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[2].split(&#39;:&#39;)[1].strip()    # 主演    actor = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[3].split(&#39;:&#39;)[1].strip()    # 类型    filmtype = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[4].split(&#39;:&#39;)[1].strip()    types = filmtype.split(&quot;/&quot;)    if soup.find(attrs=&#123;&#39;id&#39;:&#39;info&#39;&#125;).text.split(&#39;\n&#39;)[5].split(&#39;:&#39;)[0] == &#39;官方网站&#39;:        # 国家或者地区        area = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[6].split(&#39;:&#39;)[1].strip()        # 语言        language = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[7].split(&#39;:&#39;)[1].strip()        # 上映日期        initialreleasedate = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[8].split(&#39;:&#39;)[1].strip().split(&quot;(&quot;)[0]    else:        # 国家或者地区        area = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[5].split(&#39;:&#39;)[1].strip()        # 语言        language = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[6].split(&#39;:&#39;)[1].strip()        # 上映日期        initialreleasedate = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[7].split(&#39;:&#39;)[1].strip().split(&quot;(&quot;)[0]    # 片长    # runtime = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[8].split(&#39;:&#39;)[1].strip()    runtime = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:runtime&#39;&#125;).text    # 豆瓣评分    rating_num = soup.find(attrs=&#123;&#39;property&#39;: &quot;v:average&quot;&#125;).text    # 五星评分比例    star5_rating_per = soup.find(attrs=&#123;&#39;class&#39;: &#39;rating_per&#39;&#125;).text    # 评价人数    rating_people = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:votes&#39;&#125;).text    # 剧情简介    summary = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:summary&#39;&#125;).text    summary = pymysql.converters.escape_string(summary)</code></pre><h1 id="mysql相关内容"><a href="#mysql相关内容" class="headerlink" title="mysql相关内容"></a>mysql相关内容</h1><h2 id="在软件新建二个表格"><a href="#在软件新建二个表格" class="headerlink" title="在软件新建二个表格"></a>在软件新建二个表格</h2><p>新建二个表格用于存储爬虫的内容，一个储存电影链接和电影名称，一个存储电影详细信息</p><p>表一：</p><p><img src="/image-20231030095505729.png" alt="image-20231030095505729"></p><p>表二：</p><p><img src="/image-20231030095539194.png" alt="image-20231030095539194"></p><h2 id="python与数据库的连接"><a href="#python与数据库的连接" class="headerlink" title="python与数据库的连接"></a>python与数据库的连接</h2><h3 id="获取数据库链接"><a href="#获取数据库链接" class="headerlink" title="获取数据库链接"></a>获取数据库链接</h3><pre><code>import pymysqldef getDB():    # 连接数据库    db = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, database=&#39;douban&#39;)    return db</code></pre><pre><code> sql = &#39;insert into movies(film_name,director,scriptwriter,actor,filmtype,area,language,initialreleasedate,ranks,runtime,rating_num,star5_rating_per,rating_people,summary,film_name_en,links) value (&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;);&#39;.format(        film_name, director, scriptwriter, actor, filmtype, area, language, initialreleasedate, ranks, runtime,        rating_num, star5_rating_per, rating_people, summary, film_name_en, film_url)    db = getDB()    try:        cursor = db.cursor()        cursor.execute(sql)        cursor.execute(&#39;insert into moviehash(movieid) values(&quot;&#123;&#125;&quot;)&#39;.format(id))        for j in range(len(types)):            cursor.execute(&#39;insert into movietype(movieid,filmtype) values(&quot;&#123;&#125;&quot;,&quot;&#123;&#125;&quot;)&#39;.format(id,types[j].strip()))        db.commit()    except Exception as e:        print(&quot;错误：&quot;, e)        db.rollback()    cursor.close()    db.close()</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code>import pymysqlimport reimport requestsfrom bs4 import BeautifulSoup# 获取豆瓣top50 加入split会转换为数组方式def getDB():    # 连接数据库    db = pymysql.connect(host=&#39;localhost&#39;, user=&#39;root&#39;, password=&#39;123456&#39;, database=&#39;douban&#39;)    return dbdef Agent_info():    &#39;&#39;&#39;用于保存Cookies，url，user-agent信息&#39;&#39;&#39;    headers = &#123;        &#39;Cookie&#39;: &#39;ll=&quot;108296&quot;; bid=ql4eVea35OE; _pk_id.100001.4cf6=eb8ccbe690de15db.1697115364.; __yadk_uid=T6v0V74NMJ2y421xzxioww6xLN6VfPe2; _vwo_uuid_v2=D79406DF4AAE71A1C157704ED368E5A95|dbc5faa35b4a745a69d2f7cd7cd153ea; __utmz=30149280.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmz=223695111.1697181931.2.2.utmcsr=douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmc=30149280; __utmc=223695111; Hm_lvt_16a14f3002af32bf3a75dfe352478639=1697250066; Hm_lpvt_16a14f3002af32bf3a75dfe352478639=1697250066; ap_v=0,6.0; __utma=30149280.1219357050.1697115357.1697249765.1697261508.7; __utmb=30149280.0.10.1697261508; __utma=223695111.682780799.1697115364.1697249765.1697261508.7; __utmb=223695111.0.10.1697261508; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1697261508%2C%22https%3A%2F%2Fwww.douban.com%2F%22%5D; _pk_ses.100001.4cf6=1; dbcl2=&quot;262712933:vV08l1yT2sw&quot;; ck=AzYJ; push_noty_num=0; push_doumail_num=0&#39;,        &#39;Host&#39;: &#39;movie.douban.com&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36&#39;    &#125;    return headersdef get_url(url):    print(&quot;抓取网址:&quot;, url)    headers = Agent_info()    request = requests.get(url, headers=headers)    soup = BeautifulSoup(request.text, &#39;lxml&#39;)    pic = soup.find_all(attrs=&#123;&#39;class&#39;: &#39;pic&#39;&#125;)    film_urls = []  # 电影详情地址列表    for x in pic:        href = x.a.get(&#39;href&#39;)        film_urls.append(href)    movie_list = []  # 外国电影名字    div_list = soup.find_all(attrs=&#123;&#39;class&#39;: &#39;hd&#39;&#125;)    for each in div_list:        movie = each.a.contents[3].text.strip() #取第三部分内容去掉空格        movie = movie[2:] #从第三个数开始取值        movie_list.append(movie)    return film_urls, movie_list# 获取电影信息def get_url_info(film_url, film_name_en, id):    print(&quot;抓取网址:&quot;, film_url)    headers = Agent_info()    request = requests.get(film_url, headers=headers)    soup = BeautifulSoup(request.text, &#39;lxml&#39;)    # 排名    ranks = soup.find(attrs=&#123;&#39;class&#39;: &#39;top250-no&#39;&#125;).text.split(&#39;.&#39;)[1]    # 电影名    film_name = soup.find(attrs=&#123;&quot;property&quot;: &quot;v:itemreviewed&quot;&#125;).text.split(&#39; &#39;)[0]    # 导演    director = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[1].split(&#39;:&#39;)[1].strip()    # 编剧    scriptwriter = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[2].split(&#39;:&#39;)[1].strip()    # 主演    actor = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[3].split(&#39;:&#39;)[1].strip()    # 类型    filmtype = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[4].split(&#39;:&#39;)[1].strip()    types = filmtype.split(&quot;/&quot;)    if soup.find(attrs=&#123;&#39;id&#39;:&#39;info&#39;&#125;).text.split(&#39;\n&#39;)[5].split(&#39;:&#39;)[0] == &#39;官方网站&#39;:        # 国家或者地区        area = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[6].split(&#39;:&#39;)[1].strip()        # 语言        language = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[7].split(&#39;:&#39;)[1].strip()        # 上映日期        initialreleasedate = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[8].split(&#39;:&#39;)[1].strip().split(&quot;(&quot;)[0]    else:        # 国家或者地区        area = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[5].split(&#39;:&#39;)[1].strip()        # 语言        language = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[6].split(&#39;:&#39;)[1].strip()        # 上映日期        initialreleasedate = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[7].split(&#39;:&#39;)[1].strip().split(&quot;(&quot;)[0]    # 片长    # runtime = soup.find(attrs=&#123;&#39;id&#39;: &#39;info&#39;&#125;).text.split(&#39;\n&#39;)[8].split(&#39;:&#39;)[1].strip()    runtime = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:runtime&#39;&#125;).text    # 豆瓣评分    rating_num = soup.find(attrs=&#123;&#39;property&#39;: &quot;v:average&quot;&#125;).text    # 五星评分比例    star5_rating_per = soup.find(attrs=&#123;&#39;class&#39;: &#39;rating_per&#39;&#125;).text    # 评价人数    rating_people = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:votes&#39;&#125;).text    # 剧情简介    summary = soup.find(attrs=&#123;&#39;property&#39;: &#39;v:summary&#39;&#125;).text    summary = pymysql.converters.escape_string(summary)    # 存到数据库    # sql = &#39;insert into movies(film_name,director,scriptwriter,actor,filmtype,area,language,initialreleasedate,ranks,runtime,rating_num,star5_rating_per,rating_people,summary,film_name_en,links) value (&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;);&#39;.format(film_name, director, scriptwriter, actor, filmtype, area, language, initialreleasedate, ranks, runtime,rating_num, star5_rating_per, rating_people, summary, film_name_en, film_url)    #    # db = getDB()    # try:    #     cursor = db.cursor()    #     cursor.execute(sql)    #     db.commit()    # except Exception as e:    #     db.rollback()    # cursor.close()    # db.close()    sql = &#39;insert into movies(film_name,director,scriptwriter,actor,filmtype,area,language,initialreleasedate,ranks,runtime,rating_num,star5_rating_per,rating_people,summary,film_name_en,links) value (&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;);&#39;.format(        film_name, director, scriptwriter, actor, filmtype, area, language, initialreleasedate, ranks, runtime,        rating_num, star5_rating_per, rating_people, summary, film_name_en, film_url)    db = getDB()    try:        cursor = db.cursor()        cursor.execute(sql)        cursor.execute(&#39;insert into moviehash(movieid) values(&quot;&#123;&#125;&quot;)&#39;.format(id))        for j in range(len(types)):            cursor.execute(&#39;insert into movietype(movieid,filmtype) values(&quot;&#123;&#125;&quot;,&quot;&#123;&#125;&quot;)&#39;.format(id,types[j].strip()))        db.commit()    except Exception as e:        print(&quot;错误：&quot;, e)        db.rollback()    cursor.close()    db.close()if __name__ == &#39;__main__&#39;:    print(&quot;开始抓取&quot;)    film_urls, movie_list = get_url(&quot;https://movie.douban.com/top250&quot;)    db = getDB()    cursor = db.cursor()    for i in range(0, 250, 25):        film_urls, movie_list = get_url(&quot;https://movie.douban.com/top250?start=&quot; + str(i) + &quot;&amp;filter=&quot;)        for film_url in range(len(film_urls)):            id = re.search(&#39;\d\d+&#39;, film_urls[film_url]).group()            sql = &#39;select movieid from moviehash where movieid=&quot;&#123;&#125;&quot;;&#39;.format(id)            cursor.execute(sql)            data = cursor.fetchall()            if not data:                get_url_info(film_urls[film_url], movie_list[film_url], id)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习日记 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序（二）变量和数据类型</title>
      <link href="//12dbb8fd.html"/>
      <url>//12dbb8fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量（variable）"><a href="#变量（variable）" class="headerlink" title="变量（variable）"></a>变量（variable）</h1><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。</p><p>把 123 放到了一块叫做 a 的内存区域。你可以写成一个语句：</p><pre><code>int a=123;</code></pre><p>a 中的整数不是一成不变的，只要我们需要，随时可以更改。更改的方式就是再次赋值，例如：</p><pre><code>int a=123;a=1000;a=9999;</code></pre><p>第二次赋值，会把第一次的数据覆盖（擦除）掉，也就是说，a 中最后的值是9999，123、1000 已经不存在了，再也找不回来了。</p><p>因为 a 的值可以改变，所以我们给它起了一个形象的名字，叫做<strong>变量（Variable）</strong>。</p><p><code>int a;</code>创造了一个变量 a，我们把这个过程叫做变量定义。<code>a=123;</code>把 123 交给了变量 a，我们把这个过程叫做给变量赋值；又因为是第一次赋值，也称变量的初始化，或者赋初值。</p><h1 id="数据类型（Data-Type）"><a href="#数据类型（Data-Type）" class="headerlink" title="数据类型（Data Type）"></a>数据类型（Data Type）</h1><p>数据是放在内存中的，变量是给这块内存起的名字，有了变量就可以找到并使用这份数据。但问题是，该如何使用呢？</p><p>我们知道，诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字16呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。</p><p>也就是说，内存中的数据有多种解释方式，使用之前必须要确定；上面的<code>int a;</code>就表明，这份数据是整数，不能理解为像素、声音等。int 有一个专业的称呼，叫做数据类型（Data Type）。</p><p>顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义。在C语言中，有多种数据类型，例如：</p><div class="table-container"><table><thead><tr><th>说  明</th><th>字符型</th><th>短整型</th><th>整型</th><th>长整型</th><th>单精度浮点型</th><th>双精度浮点型</th><th>无类型</th></tr></thead><tbody><tr><td>数据类型</td><td>char</td><td>short</td><td>int</td><td>long</td><td>float</td><td>double</td><td>void</td></tr></tbody></table></div><p>这些是最基本的数据类型，对应的长度为：</p><div class="table-container"><table><thead><tr><th>说  明</th><th>字符型</th><th>短整型</th><th>整型</th><th>长整型</th><th>单精度浮点型</th><th>双精度浮点型</th></tr></thead><tbody><tr><td>数据类型</td><td>char</td><td>short</td><td>int</td><td>long</td><td>float</td><td>double</td></tr><tr><td>长  度</td><td>1</td><td>2</td><td>4</td><td>4Windows/8Linux</td><td>4</td><td>8</td></tr></tbody></table></div><p>实例如下：</p><pre><code>int x;          // 整型变量x定义x = 20;         // 变量x初始化为20float pi;       // 浮点型变量pi定义pi = 3.14159;   // 变量pi初始化为3.14159char ch;        // 字符型变量ch定义ch = &#39;B&#39;;       // 变量ch初始化为字符&#39;B&#39;</code></pre><p>长度计算实例：</p><p>获取某个数据类型的长度可以使用 sizeof 操作符，如下所示：</p><pre><code>include &lt;stdio.h&gt;int main()&#123;    short a = 10;    int b = 100;    int short_length = sizeof a;    int int_length = sizeof(b);    int long_length = sizeof(long);    int char_length = sizeof(char);    printf(&quot;short=%d, int=%d, long=%d, char=%d\n&quot;, short_length, int_length, long_length, char_length);    return 0;&#125;</code></pre><p>在 32 位环境以及 Win64 环境下的运行结果为：</p><pre><code>short=2, int=4, long=4, char=1</code></pre><p>在 64 位 Linux 和 Mac OS 下的运行结果为：</p><pre><code>short=2, int=4, long=8, char=1</code></pre><p>sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略<code>( )</code>，如果跟的是数据类型，就必须带上<code>( )</code>。</p><p>需要注意的是，sizeof 是C语言中的操作符，不是函数，所以可以不带<code>( )</code>，后面会详细讲解。</p><h1 id="变量不初始化"><a href="#变量不初始化" class="headerlink" title="变量不初始化"></a>变量不初始化</h1><p>在 C 语言中，如果变量没有显式初始化，那么它的默认值将取决于该变量的类型和其所在的作用域。</p><p>对于全局变量和静态变量（在函数内部定义的静态变量和在函数外部定义的全局变量），它们的默认初始值为零。</p><p>以下是不同类型的变量在没有显式初始化时的默认值：</p><ul><li>整型变量（int、short、long等）：默认值为0。</li><li>浮点型变量（float、double等）：默认值为0.0。</li><li>字符型变量（char）：默认值为’\0’，即空字符。</li><li>指针变量：默认值为NULL，表示指针不指向任何有效的内存地址。</li><li>数组、结构体、联合等复合类型的变量：它们的元素或成员将按照相应的规则进行默认初始化，这可能包括对元素递归应用默认规则。</li></ul><p>需要注意的是，局部变量（在函数内部定义的非静态变量）不会自动初始化为默认值，它们的初始值是未定义的（包含垃圾值）。因此，在使用局部变量之前，应该显式地为其赋予一个初始值。</p><p>总结起来，C 语言中变量的默认值取决于其类型和作用域。全局变量和静态变量的默认值为 <strong>0</strong>，字符型变量的默认值为 <strong>\0</strong>，指针变量的默认值为 NULL，而局部变量没有默认值，其初始值是未定义的。</p><h1 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h1><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p><p>变量的声明有两种情况：</p><ul><li><p>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</p></li><li><p>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</p></li><li><p>除非有extern关键字，否则都是变量的定义。</p><h1 id="在屏幕上输出各种类型的数据"><a href="#在屏幕上输出各种类型的数据" class="headerlink" title="在屏幕上输出各种类型的数据"></a>在屏幕上输出各种类型的数据</h1></li></ul><p>  输出变量 abc 的值：</p><pre><code>  int abc=999;  printf(&quot;%d&quot;, abc);</code></pre><p>  这里就比较有趣了。先来看<code>%d</code>，d 是 decimal 的缩写，意思是十进制数，%d 表示以十进制整数的形式输出,会用 abc 的值来替换 %d。</p><p>这里<code>%d</code>称为格式控制符，它指明了以何种形式输出数据。格式控制符均以<code>%</code>开头，后跟其他字符。%d 表示以十进制形式输出一个整数。除了 %d，printf 支持更多的格式控制，例如：</p><ul><li>%c：输出一个字符。c 是 character 的简写。</li><li>%s：输出一个字符串。s 是 string 的简写。</li><li>%f：输出一个小数。f 是 float 的简写。</li></ul><p>实例如下：</p><pre><code>#include &lt;stdio.h&gt;int main()&#123;    int n = 100;    char c = &#39;@&#39;;  //字符用单引号包围，字符串用双引号包围    float money = 93.96;    printf(&quot;n=%d, c=%c, money=%f\n&quot;, n, c, money);    return 0;&#125;</code></pre><p>输出结果：<br>n=100, c=@, money=93.959999</p><h1 id="C语言中的二进制数、八进制数和十六进制数"><a href="#C语言中的二进制数、八进制数和十六进制数" class="headerlink" title="C语言中的二进制数、八进制数和十六进制数"></a>C语言中的二进制数、八进制数和十六进制数</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>二进制由 0 和 1 两个数字组成，使用时必须以<code>0b</code>或<code>0B</code>（不区分大小写）开头，例如：</p><pre><code>//合法的二进制int a = 0b101;  //换算成十进制为 5int b = -0b110010;  //换算成十进制为 -50int c = 0B100001;  //换算成十进制为 33//非法的二进制int m = 101010;  //无前缀 0B，相当于十进制int n = 0B410;  //4不是有效的二进制数字</code></pre><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>八进制由 0~7 八个数字组成，使用时必须以<code>0</code>开头（注意是数字 0，不是字母 o），例如：</p><pre><code>//合法的八进制数int a = 015;  //换算成十进制为 13int b = -0101;  //换算成十进制为 -65int c = 0177777;  //换算成十进制为 65535//非法的八进制int m = 256;  //无前缀 0，相当于十进制int n = 03A2;  //A不是有效的八进制数字</code></pre><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以<code>0x</code>或<code>0X</code>（不区分大小写）开头，例如：</p><pre><code> //合法的十六进制int a = 0X2A;  //换算成十进制为 42int b = -0XA0;  //换算成十进制为 -160int c = 0xffff;  //换算成十进制为 65535//非法的十六进制int m = 5A;  //没有前缀 0X，是一个无效数字int n = 0X3H;  //H不是有效的十六进制数字</code></pre><h2 id="二进制八进制十六进制的输出"><a href="#二进制八进制十六进制的输出" class="headerlink" title="二进制八进制十六进制的输出"></a>二进制八进制十六进制的输出</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>下表列出了不同类型的整数、以不同进制的形式输出时对应的格式控制符：</p><div class="table-container"><table><thead><tr><th></th><th>short</th><th>int</th><th>long</th></tr></thead><tbody><tr><td>八进制</td><td>%ho</td><td>%o</td><td>%lo</td></tr><tr><td>十进制</td><td>%hd</td><td>%d</td><td>%ld</td></tr><tr><td>十六进制</td><td>%hx 或者 %hX</td><td>%x 或者 %X</td><td>%lx 或者 %lX</td></tr></tbody></table></div><p>十六进制数字的表示用到了英文字母，有大小写之分，要在格式控制符中体现出来：</p><ul><li>%hx、%x 和 %lx 中的<code>x</code>小写，表明以小写字母的形式输出十六进制数；</li><li>%hX、%X 和 %lX 中的<code>X</code>大写，表明以大写字母的形式输出十六进制数。</li></ul><p>八进制数字和十进制数字不区分大小写，所以格式控制符都用小写形式。如果你比较叛逆，想使用大写形式，那么行为是未定义的，请你慎重：</p><ul><li>有些编译器支持大写形式，只不过行为和小写形式一样；</li><li>有些编译器不支持大写形式，可能会报错，也可能会导致奇怪的输出。</li></ul><p>注意，虽然部分编译器支持二进制数字的表示，但是却不能使用 printf 函数输出二进制，这一点比较遗憾。当然，通过转换函数可以将其它进制数字转换成二进制数字，并以字符串的形式存储，然后在 printf 函数中使用<code>%s</code>输出即可。考虑到读者的基础还不够，这里就先不讲这种方法了。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><pre><code>#include &lt;stdio.h&gt;int main()&#123;    short a = 0b1010110;  //二进制数字    int b = 02713;  //八进制数字    long c = 0X1DAB83;  //十六进制数字    printf(&quot;a=%ho, b=%o, c=%lo\n&quot;, a, b, c);  //以八进制形似输出    printf(&quot;a=%hd, b=%d, c=%ld\n&quot;, a, b, c);  //以十进制形式输出    printf(&quot;a=%hx, b=%x, c=%lx\n&quot;, a, b, c);  //以十六进制形式输出（字母小写）    printf(&quot;a=%hX, b=%X, c=%lX\n&quot;, a, b, c);  //以十六进制形式输出（字母大写）    return 0;&#125;</code></pre><p>运行结果：</p><p>a=126, b=2713, c=7325603<br>a=86, b=1483, c=1944451<br>a=56, b=5cb, c=1dab83<br>a=56, b=5CB, c=1DAB83</p><p><strong>输出加上前缀代码</strong>：</p><ul><li>对于八进制数字，它没法和十进制、十六进制区分，因为八进制、十进制和十六进制都包含 0~7 这几个数字。</li><li>对于十进制数字，它没法和十六进制区分，因为十六进制也包含 0~9 这几个数字。如果十进制数字中还不包含 8 和 9，那么也不能和八进制区分了。</li><li>对于十六进制数字，如果没有包含 a~f 或者 A~F，那么就无法和十进制区分，如果还不包含 8 和 9，那么也不能和八进制区分了。</li></ul><p>区分不同进制数字的一个简单办法就是，在输出时带上特定的前缀。在格式控制符中加上<code>#</code>即可输出前缀，例如 %#x、%#o、%#lX、%#ho 等，请看下面的代码：</p><pre><code>#include &lt;stdio.h&gt;int main()&#123;    short a = 0b1010110;  //二进制数字    int b = 02713;  //八进制数字    long c = 0X1DAB83;  //十六进制数字    printf(&quot;a=%#ho, b=%#o, c=%#lo\n&quot;, a, b, c);  //以八进制形似输出    printf(&quot;a=%hd, b=%d, c=%ld\n&quot;, a, b, c);  //以十进制形式输出    printf(&quot;a=%#hx, b=%#x, c=%#lx\n&quot;, a, b, c);  //以十六进制形式输出（字母小写）    printf(&quot;a=%#hX, b=%#X, c=%#lX\n&quot;, a, b, c);  //以十六进制形式输出（字母大写）    return 0;&#125;</code></pre><p>运行结果：<br>a=0126, b=02713, c=07325603<br>a=86, b=1483, c=1944451<br>a=0x56, b=0x5cb, c=0x1dab83<br>a=0X56, b=0X5CB, c=0X1DAB83</p><h1 id="C语言自增-和自减-—"><a href="#C语言自增-和自减-—" class="headerlink" title="C语言自增(++)和自减(—)"></a>C语言自增(++)和自减(—)</h1><p>++ 在变量前面和后面是有区别的：</p><ul><li>++ 在前面叫做前自增（例如 ++a）。前自增先进行自增运算，再进行其他操作。</li><li>++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增运算。</li></ul><p>自减（—）也一样，有前自减和后自减之分。</p><p>下面的例子能更好地说明前自增（前自减）和后自增（后自减）的区别：<em>**</em></p><pre><code>#include &lt;stdio.h&gt;int main()&#123;    int a = 10, b = 20, c = 30, d = 40;    int a1 = ++a, b1 = b++, c1 = --c, d1 = d--;    printf(&quot;a=%d, a1=%d\n&quot;, a, a1);    printf(&quot;b=%d, b1=%d\n&quot;, b, b1);    printf(&quot;c=%d, c1=%d\n&quot;, c, c1);    printf(&quot;d=%d, d1=%d\n&quot;, d, d1);    return 0;&#125;</code></pre><p>输出结果：<br>a=11, a1=11<br>b=21, b1=20<br>c=29, c1=29<br>d=39, d1=40</p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于启智ai创作平台的模型调用（qwen）</title>
      <link href="//65dd884a.html"/>
      <url>//65dd884a.html</url>
      
        <content type="html"><![CDATA[<h1 id="实现效果和模型相关介绍"><a href="#实现效果和模型相关介绍" class="headerlink" title="实现效果和模型相关介绍"></a>实现效果和模型相关介绍</h1><blockquote><p><strong>通义千问-7B（Qwen-7B）</strong>是阿里云研发的通义千问大模型系列的70亿参数规模的模型。Qwen-7B是基于Transformer的大语言模型, 在超大规模的预训练数据上进行训练得到。预训练数据类型多样，覆盖广泛，包括大量网络文本、专业书籍、代码等。</p></blockquote><p>本文旨在通过启智平台完成大模型的调用，由于本地环境受限无法运行成功，可以利用启智社区平台白嫖<code>GPU</code>算力，实现效果代码，代码由<code>github</code>官方文档获得：</p><p>参考链接：<a href="https://github.com/QwenLM/Qwen/blob/main/README_CN.md">github官方文档</a></p><pre><code>from transformers import AutoModelForCausalLM, AutoTokenizerfrom transformers.generation import GenerationConfig# 可选的模型包括: &quot;Qwen/Qwen-7B&quot;, &quot;Qwen/Qwen-14B&quot;tokenizer = AutoTokenizer.from_pretrained(&quot;/code/qwen&quot;, trust_remote_code=True)# 打开bf16精度，A100、H100、RTX3060、RTX3070等显卡建议启用以节省显存# model = AutoModelForCausalLM.from_pretrained(&quot;Qwen/Qwen-7B&quot;, device_map=&quot;auto&quot;, trust_remote_code=True, bf16=True).eval()# 打开fp16精度，V100、P100、T4等显卡建议启用以节省显存# model = AutoModelForCausalLM.from_pretrained(&quot;Qwen/Qwen-7B&quot;, device_map=&quot;auto&quot;, trust_remote_code=True, fp16=True).eval()# 使用CPU进行推理，需要约32GB内存# model = AutoModelForCausalLM.from_pretrained(&quot;Qwen/Qwen-7B&quot;, device_map=&quot;cpu&quot;, trust_remote_code=True).eval()# 默认使用自动模式，根据设备自动选择精度model = AutoModelForCausalLM.from_pretrained(&quot;/code/qwen&quot;, device_map=&quot;auto&quot;, trust_remote_code=True).eval()# 可指定不同的生成长度、top_p等相关超参model.generation_config = GenerationConfig.from_pretrained(&quot;/code/qwen&quot;, trust_remote_code=True)inputs = tokenizer(&#39;蒙古国的首都是乌兰巴托（Ulaanbaatar）\n冰岛的首都是雷克雅未克（Reykjavik）\n埃塞俄比亚的首都是&#39;, return_tensors=&#39;pt&#39;)inputs = inputs.to(model.device)pred = model.generate(**inputs)print(tokenizer.decode(pred.cpu()[0], skip_special_tokens=True))# 蒙古国的首都是乌兰巴托（Ulaanbaatar）\n冰岛的首都是雷克雅未克（Reykjavik）\n埃塞俄比亚的首都是亚的斯亚贝巴（Addis Ababa）...</code></pre><p>实现效果如下：</p><p><img src="/001.png" alt="image-20231025201727087"></p><p>可以看出执行代码之后，输出会根据问题继续续写<!--（风格好像是自动推断续写而不是回答问题，我也不是很懂原因）--></p><h1 id="在启智社区创建调试任务"><a href="#在启智社区创建调试任务" class="headerlink" title="在启智社区创建调试任务"></a>在启智社区创建调试任务</h1><h2 id="登入启智社区AI创作平台"><a href="#登入启智社区AI创作平台" class="headerlink" title="登入启智社区AI创作平台"></a>登入启智社区AI创作平台</h2><p>进入启智社区，社区网址如下：<a href="https://openi.org.cn/">OpenI 启智 新一代人工智能开源开放平台</a>，</p><p><img src="/002.png" alt="image-20231025202610594"></p><p>找到ai创作平台，点击进入AI协作平台，首次登陆需要注册一下。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>在启智平台右上角找到创建项目</p><p><img src="/003.png" alt="image-20231025202818500"></p><p>输入项目名称后完成创建</p><h3 id="新建调试任务"><a href="#新建调试任务" class="headerlink" title="# 新建调试任务"></a># 新建调试任务</h3><p>打开新创建的项目，我这里项目名称为11111，点击云脑</p><p><img src="/004.png" alt="image-20231025203137928"></p><p>在界面里面找到新建调试任务</p><p><img src="/005.png" alt="image-20231025203301871"></p><p>基本设置如下，镜像我这里选择的是192.168.242.22:443/default-workspace/fccb038c23234b9e80105d4ccd152117/image:fedjudge</p><p><img src="/006.png" alt="image-20231025203503641"></p><p>点击新建调试任务就能创建，一开始需要点击红色部分，等待状态变成running就可以进入界面了</p><p><img src="/007.png" alt="image-20231025203636184"></p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>这是点击调试之后进入的界面，界面左侧此时只有一个文件master.zip，记住左边可以显示的文件目录在code下</p><p><img src="/008.png" alt="image-20231025203934380"></p><p>进入终端输入如下命令</p><pre><code>bashcd codewget -O qwen7b.zip &#39;https://s3.openi.org.cn/opendata/attachment/d/6/d6258166-a72b-46d3-8291-0ce2f94a8f86?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=1fa9e58b6899afd26dd3%2F20231025%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20231025T124132Z&amp;X-Amz-Expires=86400&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3D%22Qwen-7B.zip%22&amp;X-Amz-Signature=bedeb772c26057ba98b4268b14ddba49622940ed6c6c381e3e80d719affe98bc&#39;unzip -d qwen7b qwen7b.zip</code></pre><p>模型我这里选择的是qwen7b模型，其他大模型类似，模型网址<a href="https://openi.pcl.ac.cn/Learning-Develop-Union/LangChain-ChatGLM-Webui/datasets，模型界面如下：">https://openi.pcl.ac.cn/Learning-Develop-Union/LangChain-ChatGLM-Webui/datasets，模型界面如下：</a></p><p><img src="/009.png" alt="image-20231025204444795"></p><p>安心等待片刻，等左边出现文件qwen7b和qwen7b.zip说明下载解压成功</p><p><img src="/010.png" alt="image-20231025205159057"></p><p>新建一个测试文件，接着打开终端输入如下指令：</p><pre><code>bashcd codetouch text.py</code></pre><p>将代码复制到文件中，注意文件的路径为刚刚创建的路径</p><p><img src="/011.png" alt="image-20231025205831165"></p><p>然后输入代码<code>python text.py</code>执行文件， 如果遇到报错，输入下面代码</p><pre><code>pip install transformers_stream_generator</code></pre><p>输入代码后在执行python text.py之后就能实现模型的调用了</p><p><img src="/012.png" alt="image-20231025210201687"></p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
          <category> qwen </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qwen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序(一)c语言程序结构</title>
      <link href="//a060c349.html"/>
      <url>//a060c349.html</url>
      
        <content type="html"><![CDATA[<h1 id="c语言程序结构"><a href="#c语言程序结构" class="headerlink" title="c语言程序结构"></a>c语言程序结构</h1><hr><p>c语言程序主要包含以下部分：</p><ul><li>预处理器指令</li><li>函数</li><li>变量</li><li>语句&amp;表达式</li><li>注释</li></ul><p>以下是一段简单的代码，可以运行在vc=++6.0 ,输出“Hello World”:</p><pre><code>#include &lt;stdio.h&gt;int main()&#123; /* 我的第一个c程序*/ printf(&quot;Hello,World! \n&quot;); return 0;&#125;</code></pre><p>代码讲解:</p><ol><li><p>程序的第一行 <em>#include <stdio.h></stdio.h></em> 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。</p></li><li><p>下一行 <em>int main()</em> 是主函数，程序从这里开始执行。</p></li><li><p>下一行 /<em>…</em>/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。</p></li><li><p>下一行 <em>printf(…)</em> 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。</p></li><li><p>下一行 <strong>return 0;</strong> 终止 main() 函数，并返回值 0。</p></li></ol><p>此外输出也可以使用puts，vscode里面运行代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;   puts(&quot;C语言程序设计&quot;);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>输出如下：</p><p><strong>C语言程序设计</strong></p><p>printf 比 puts 更加强大，不仅可以输出字符串，还可以输出整数、小数、单个字符等，并且输出格式也可以自己定义，例如：</p><ul><li>以十进制、八进制、十六进制形式输出；</li><li>要求输出的数字占 n 个字符的位置；</li><li>控制小数的位数。</li></ul><h1 id="c中的空格"><a href="#c中的空格" class="headerlink" title="c中的空格"></a>c中的空格</h1><p>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</p><p>在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p><pre><code>int age;</code></pre><blockquote><p>注意 int 和 a 之间是有空格的，它们是两个词。也注意最后的分号，<code>int a</code>表达了完整的意思，是一个语句，要用分号来结束。</p></blockquote><p>这个语句的意思是：在内存中找一块区域，命名为 age，用它来存放整数。</p><p>另一方面，在下面的语句中：</p><pre><code>fruit = apples + oranges;   // 获取水果的总数</code></pre><p>fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p><h1 id="如何在字符串中书写长文本"><a href="#如何在字符串中书写长文本" class="headerlink" title="如何在字符串中书写长文本"></a>如何在字符串中书写长文本</h1><p>在 puts 函数中，可以将一个较长的字符串分割成几个较短的字符串，这样会使得长文本的格式更加整齐,代码如下:</p><pre><code>#include &lt;stdio.h&gt;int main()&#123;    puts(        &quot;C语言中文网，一个学习C语言和C++的网站，他们坚持用工匠的精神来打磨每一套教程。&quot;        &quot;坚持做好一件事情，做到极致，让自己感动，让用户心动，这就是足以传世的作品！&quot;        &quot;C语言中文网的网址是：http://c.biancheng.net&quot;    );    return 0;&#125;</code></pre><p>注意，这只是形式上的分割，编译器在编译阶段会将它们合并为一个字符串，它们放在一块连续的内存中。</p><p>多个字符串并不一定非得换行，也可以将它们写在一行中，例如：</p><pre><code>#include &lt;stdio.h&gt;int main()&#123;    puts(&quot;C语言&quot;  &quot;C语言和C++！&quot;  &quot;123&quot;);    return 0;&#125;</code></pre><p>puts、printf， fprintf、fputs 等与字符串输出有关的函数，都支持这种写法。</p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习日记（持续更新中）</title>
      <link href="//d4a0c6b2.html"/>
      <url>//d4a0c6b2.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 安装包下载地址为：<a href="http://git-scm.com/downloads下载好，按默认安装即可（推荐安转在D盘中）。安装完成后，在开始菜单里找到“Git”-&gt;“Git">http://git-scm.com/downloads下载好，按默认安装即可（推荐安转在D盘中）。安装完成后，在开始菜单里找到“Git”-&gt;“Git</a> Bash”，双击蹦出一个类似命令行窗口的东西</p><p><img src="/000.png" alt="image-20231022140546790"></p><p>在开始栏里面出现这个就说明安装成功</p><h2 id="linux安装命令"><a href="#linux安装命令" class="headerlink" title="linux安装命令"></a>linux安装命令</h2><p><code>apt-git install git</code></p><p>通过指令安装git，如果报错如下</p><p>root@pe7e1154dd684d1e907eb5cb96bca29a-task0-0:/code# git init bash: git：未找到命令</p><p>则需要先更新软件安装包</p><p><code>apt-get update</code></p><p>运行结果如下:</p><p><img src="/001.png" alt="image-20231020171046342"></p><p>然后运行以下指令：</p><p><code>apt-get install git</code></p><p>如下，按照命令要求输出<code>y</code></p><p><img src="/002.png" alt="image-20231020171438262"></p><h2 id="初始化设置用户名和邮箱"><a href="#初始化设置用户名和邮箱" class="headerlink" title="初始化设置用户名和邮箱"></a>初始化设置用户名和邮箱</h2><pre><code>git config --global user.name&quot;your name&quot;git config --global user.email email@mail.comgit config --global credential.helper store</code></pre><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><hr><blockquote><p>init：初始化当前目录为仓库，初始化后会自动将当前仓库设置为master</p></blockquote><p>创建一个新的本地仓库（省去project-name则在当前目录创建）</p><p><code>git init</code> or <code>git init &lt;project-name&gt;</code></p><p><img src="/003.png" alt="image-20231020171719300"></p><ul><li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li></ul><p>下载一个远程仓库</p><pre><code>git clone &lt;url&gt;</code></pre><h1 id="git相关知识介绍"><a href="#git相关知识介绍" class="headerlink" title="git相关知识介绍"></a>git相关知识介绍</h1><h2 id="四个仓库"><a href="#四个仓库" class="headerlink" title="四个仓库"></a>四个仓库</h2><ul><li><p><code>工作区（Working Directory)</code>:  本地文件夹，电脑能看到的目录</p></li><li><p><code>暂存区（Stage/Index)</code>: 一般存放在<code>.git</code>目录下的<code>index</code>文件，所以我们把暂存区有时候也叫作索引（index）</p></li><li><p><code>仓库区(Repository)</code>: 工作区有个隐藏目录<code>.git</code>,这个不算工作区，而是Git的版本库</p></li><li><p><code>远程仓库（Remote）</code>： 托管在远程服务器的仓库</p></li></ul><h2 id="git的三种状态"><a href="#git的三种状态" class="headerlink" title="git的三种状态"></a>git的三种状态</h2><ul><li><p><code>已修改(Modified)</code>: 修改了文件，但是没保存到暂存区</p></li><li><p><code>已暂存(Staged)</code>: 把修改后的we年放到暂存区</p></li><li><p><code>已提交(Committed)</code>: 托管在远程服务器上的仓库</p></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>main</code>: 默认主分支</p></li><li><p><code>origin</code>: 默认远程仓库</p></li><li><p><code>HEAD</code>: 指向当前分支的指针</p></li><li><p><code>HEAD^</code> ：上一个版本</p></li><li><p><code>HEAD~4</code>: 上4个版本</p></li></ul><h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><ul><li><code>.git</code>: Git仓库的元数据和对象数据库</li><li><code>.gitignore</code>: 忽略文件，不需要提交到仓库的文件</li><li><code>.gitattributes</code>: 指定文件的属性，比如换行符</li><li><code>.gitkeep</code>: 使空目录被提交到仓库</li><li><code>.gitmodules</code>: 记录子模块的信息</li><li><code>.gitconfig</code>: 记录仓库的配置信息</li></ul><h1 id="传输文件到远程仓库"><a href="#传输文件到远程仓库" class="headerlink" title="传输文件到远程仓库"></a>传输文件到远程仓库</h1><p><strong>整体步骤如下</strong>：</p><p><img src="/004.png" alt="img"></p><ul><li>本地仓库是对于远程仓库而言的。</li><li>本地仓库 = 工作区 + 版本区</li><li>工作区即电脑本地磁盘上的文件集合。</li><li>版本区(版本库)即<code>.git</code>文件</li><li>版本库 = 暂存区(stage) + 分支(master) + 指针Head</li></ul><p><strong>完整提交代码流程</strong>：</p><p>1.<code>git add .</code>  将工作区的所有文件上传到暂存区</p><p>2.<code>git add file.txt</code>  将单个文件file.txt文件添加到暂存区域</p><p>3.<code>git commit -m&quot; 文件名&quot;</code> 将暂存区的所有文件上传到本地仓库</p><p>4.<code>git remote add origin https://openi.pcl.ac.cn/dongliang/model1</code> 把本地仓库与远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。<code>name</code>是你的github名字，<code>name_cangku</code>是你的仓库名。<strong>注意</strong>不要把后面的<code>.git</code>给漏掉了。</p><p>5.<code>git pull</code> 抓取并合并远程分支到当前分支</p><p>6.<code>git push --set-upstream origin master</code>   or <code>git push -u origin master</code>把仓库区的文件提交到远程仓库里。</p><p>7.<code>git pull origin master</code></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote><p>建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p></blockquote><ul><li>查看所有本地分支，当前分支前面会有一个<code>*</code>,<code>-r</code>查看远程分支，<code>-a</code>查看所有分支</li></ul><pre><code>git branch</code></pre><p><strong>创建一个新的分支</strong></p><pre><code>git branch other</code></pre><ul><li>切换到指定分支other,并更新工作区</li></ul><pre><code>git checkout other</code></pre><ul><li>创建一个新分支，并且切换到该分支</li></ul><pre><code>git checkout -b other</code></pre><ul><li>用<code>other</code>提交</li></ul><pre><code>git add ./xxx/git commit -m &quot;xxx&quot;</code></pre><ul><li><code>other</code>分支完成，切换回<code>master</code></li></ul><pre><code>复制代码git checkout master</code></pre><p>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</p><p><strong>合并分支</strong></p><pre><code>git merge other</code></pre><p>合并完成之后，就可以在master分支上查看到文件了。</p><ul><li>删除已经合并了的分支，删除<code>other</code>分支。</li></ul><pre><code>git branch -d other</code></pre><ul><li>删除一个分支，不管是否合并</li></ul><pre><code>git branch -D other</code></pre><p><strong>给当前的提交打上标签，无论是否合并</strong></p><pre><code>git tag name</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>移动</p><h1 id="启智平台调用模型，克隆命令"><a href="#启智平台调用模型，克隆命令" class="headerlink" title="启智平台调用模型，克隆命令"></a>启智平台调用模型，克隆命令</h1><hr><pre><code>bash</code></pre><p>bash是什么？</p><blockquote><ul><li>bash是一个命令处理器, 运行在文本窗口中, 并能执行用户直接输入的命令.</li><li>bash还能从文件中读取Linux命令, 称之为脚本.</li><li>bash支持通配符, 管道, 命令替换, 条件判断等逻辑控制语句 </li></ul></blockquote><pre><code>cd code #进入code</code></pre><p>进入可以显示的界面</p><p>从已有数据集中下载压缩包到启智平台：</p><pre><code>wget -O qwen.zip &#39;https://s3.openi.org.cn/opendata/attachment/f/e/fe5b48e0-b75c-41dc-a2a8-e4104fc476fa?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=1fa9e58b6899afd26dd3%2F20231022%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20231022T043408Z&amp;X-Amz-Expires=86400&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=attachment%3B%20filename%3D%22Qwen-14B.zip%22&amp;X-Amz-Signature=0522a7021794e47fef91f2aadba5c81de4ba5c576dfb30dbf1d187abb5c745ca&#39;#下载qwen14b模型到本地</code></pre><pre><code>unzip -d qwen qwen.zip #解压到当前文件夹</code></pre><h1 id="常用git命令汇总"><a href="#常用git命令汇总" class="headerlink" title="常用git命令汇总"></a>常用git命令汇总</h1><ul><li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li><li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li><li><code>git init</code> 初始化你的仓库</li><li><code>git add .</code> 把工作区的文件全部提交到暂存区</li><li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li><li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li><li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li><li><code>git status</code>查看当前仓库的状态</li><li><code>git diff</code> 查看文件修改的具体内容</li><li><code>git log</code> 显示从最近到最远的提交历史</li><li><code>git clone + 仓库地址</code>下载克隆文件</li><li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li><li><code>git reflog</code> 显示命令历史</li><li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li><li><code>git rm</code> 删除版本库的文件</li><li><code>git branch</code> 查看当前所有分支</li><li><code>git branch &lt;分支名字&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li><li><code>git merge &lt;分支名字&gt;</code> 合并分支</li><li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li><li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li><li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li><li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li><li><code>git stash drop</code> 删除<code>stash</code>内容</li><li><code>git stash pop</code> 恢复的同时把stash内容也删了</li><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code> 显示更详细的信息</li><li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li><li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li><li><code>git show &lt;tagName&gt;</code> 查看标签信息</li><li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li><li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li><li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li><li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li><li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习(持续更新中)</title>
      <link href="//95be7608.html"/>
      <url>//95be7608.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql自身相关命令"><a href="#Mysql自身相关命令" class="headerlink" title="Mysql自身相关命令"></a>Mysql自身相关命令</h1><hr><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>格式： mysql -h主机地址 -u用户名 －p用户密码</p><p>连接到本机上的MYSQL。<br>进入目录 <code>mysql/bin</code>，如下图所示，在蓝色部分输入<code>cmd</code>，进入文件的命令行，再键入命令<code>mysql -uroot -p</code>，回车后提示你输密码，如果刚安装好MYSQL，Windows密码为安装时候设置的密码，Mac和Linux无密码，直接登录即可。</p><p><img src="/57.png" alt="image-20231016103651157"></p><p>连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：<br>mysql -h110.110.110.110 -uroot -pabcd123</p><p>(注:u与root可以不用加空格，其它也一样)</p><h2 id="mysql基本指令"><a href="#mysql基本指令" class="headerlink" title="mysql基本指令"></a>mysql基本指令</h2><blockquote><p>net start mysql # 启动MySQL服务</p><p>net stop mysql #停止MySQL服务</p><p>mysql —version mysql -V #查看MySQL版本</p><p>sleect version(); #查看MySQL版本</p><p>\c ctrl+c #终止一条正在编写的语句</p><p>exit \q QUIT #退出mysql</p></blockquote><h1 id="数据库操作相关"><a href="#数据库操作相关" class="headerlink" title="数据库操作相关"></a>数据库操作相关</h1><h2 id="与数据库相关指令"><a href="#与数据库相关指令" class="headerlink" title="与数据库相关指令"></a>与数据库相关指令</h2><hr><pre><code>create database name; # 创建数据库use databasename; # 选择数据库drop database name #直接删除数据库，不提醒show tables; #显示表describe tablename; #表的详细描述mysqladmin drop database name #删除数据库前，有提示。select version(),current_date; #显示当前mysql版本和当前日期select database();       #查询当前使用的数据库</code></pre><h2 id="对table操作"><a href="#对table操作" class="headerlink" title="对table操作"></a>对table操作</h2><pre><code>show tables #显示数据库中的表show tables from dbName; #查看指定数据库的表source D:/Desktop/learn/MySQL/bjpowernode.sql; #导入sql文件，并执行里面的sql语句select* from tableName #查看表中的全部数据desc tableName #查看表的结构 desc→describeshow create table tableName; #查看表的创建语句</code></pre><h2 id="简单查询语句"><a href="#简单查询语句" class="headerlink" title="简单查询语句"></a>简单查询语句</h2><pre><code>select 字段名 from tableName; # 查询某个字段的数据select 字段名,字段名 from tableName;# 查询多个字段可用 , 将不同字段间隔select* from tableName #查看表中的全部数据select empno as&#39;员工编号&#39;,ename as &#39;员工姓名&#39;,sal*12 as &#39;年薪&#39; from emp; as &#39;xxx&#39; #可以将指定的要查询字段用另一个名字显示</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="//9211474f.html"/>
      <url>//9211474f.html</url>
      
        <content type="html"><![CDATA[<p>ls 查看当前文件夹下的内容</p><p>pwd 查看当前所在文件夹</p><p>cd xx 打开当前文件中的xx文件</p><p>mkdir xx 在当前文件创建xx文件，相对路径</p><p>mkdir ./xxx 在当前文件创建xxx文件，相对路径</p><p>mkdir /xxx 在当前文件创建xxx文件，绝对路径</p><p>mv xxx yyy 将xxx文件改为yyy文件，重命名</p><p>cp -r /aaa /bbb 将/目录下的aaa目录复制到/bbb目录下</p><p>rmdir xx  删除目录</p><p>tree xx/显示树状目录结构</p><p>clear 清屏</p><p>vim a.java 进入一般模式</p><p>i（按键）进入插入模式（编辑模式）</p><p>Ecs（按键）退出</p><p>：wq 保存退出（shift+：调起输入框）</p><p>：q 不保存退出</p><p>ctrl+c ，exit（）退出程序</p><p>wget linux下载安装包镜像</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python常用指令学习(持续更新中)</title>
      <link href="//fbaff1b6.html"/>
      <url>//fbaff1b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="pip常用命令"><a href="#pip常用命令" class="headerlink" title="pip常用命令"></a>pip常用命令</h1><hr><pre><code class="lang-python">pip install -upgrade pip 或者 pip install -U pip #升级pip指令</code></pre><p>遇到了类似提示则需要升级<code>PIP</code>You are using pip version 9.0.3, however version 18.0 is available.You should consider upgrading via the ‘pip install –upgrade pip’ command.此时需要升级<code>pip</code></p><pre><code>pip -v  #显示pip的版本信息</code></pre><pre><code>pip install name /pip install -r requirements.txt #安装python模块或者安装模块需求文件</code></pre><p>如果使用临时换源安装，使用如下代码：</p><pre><code>pip install &lt;package&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><pre><code>pip install &lt;package&gt; -upgrade #对包进行升级</code></pre><pre><code>pip uninstall &lt;package&gt; #卸载已有安装包</code></pre><pre><code>pip list #查看已安装的包</code></pre><pre><code>pip show numpy #查看安装包路径，以numpy为例</code></pre><h1 id="anaconda常用指令"><a href="#anaconda常用指令" class="headerlink" title="anaconda常用指令"></a>anaconda常用指令</h1><hr><p><strong>与换源相关命令：</strong></p><pre><code>conda config --show channels #查看源</code></pre><pre><code>conda config --add channels  #源名称</code></pre><pre><code>conda config -- remove channels #源名称</code></pre><p>清华源</p><p>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a><br>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config —add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</a></p><p>阿里云：<br>conda config —add channels <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p><p>中国科技大学：<br>conda config —add channels <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>华中理工大学：<br>conda config —add channels <a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p><p>山东理工大学：<br>conda config —add channels <a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a> </p><p>豆瓣：<br>conda config —add channels <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p><strong>与虚拟环境相关：</strong></p><pre><code>conda env list or conda info --evns #列出已有虚拟环境</code></pre><pre><code>conda create -n name python =3.11</code></pre><p>创建虚拟环境，环境名为name ，同时可以设置python版本（python版本可以设置可以不设置）</p><p>如：conda create -n flask python=3.11</p><pre><code>conda activate env_name #激活环境env_name</code></pre><pre><code> conda deactivate #关闭环境</code></pre><pre><code>conda remove -n env_name #删除环境env_name</code></pre><p><strong>安装模块相关</strong></p><pre><code>conda list #查看已经安装的文件包</code></pre><pre><code>conda uninstall name #卸载name模块</code></pre><pre><code>conda install name #安装name模块</code></pre><h1 id="与python本身相关命令"><a href="#与python本身相关命令" class="headerlink" title="与python本身相关命令"></a>与python本身相关命令</h1><pre><code>where python #查看python安装路径python -v or python -- version #查看python版本信息python #查看python自身相关信息python hello.py #在命令行执行hello.py文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章标签无法显示</title>
      <link href="//3c51531d.html"/>
      <url>//3c51531d.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-butterfly里面，文章目录和标签无法显示"><a href="#hexo-butterfly里面，文章目录和标签无法显示" class="headerlink" title="hexo+butterfly里面，文章目录和标签无法显示"></a>hexo+butterfly里面，文章目录和标签无法显示</h1><p>本地在网站根目录执行程序</p><pre><code>hexo new page categorieshexo new page tags</code></pre><h2 id="之后可以打开网页但无内容"><a href="#之后可以打开网页但无内容" class="headerlink" title="之后可以打开网页但无内容"></a>之后可以打开网页但无内容</h2><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><p> 找到运行 <code>hexo new page categories</code>之后本地文件Hexo\source 目录中会生成一个 categories 文件夹，文件夹内有一个 index.md 文件，打开此文件，将其中的 <code>type</code> 修改为 <code>categories</code> 即可。<br> 如</p><pre><code>title: 分类date: 2023-10-11 20:26:34type: &quot;categories&quot;</code></pre><p>即可达到要求</p><pre><code>title: tagsdate: 2023-10-11 20:26:34type: &quot;tags&quot;</code></pre><p>同理可以设置标签</p><p>为文章设置目录可参考：</p><pre><code>---title: 这里是文章的标题date: 这里是发表时间，如：2023-10-11 08:15:16description: 这里填写摘要。categories:- 分类- 子分类tags:- 标签1- 标签2---</code></pre><p>这样就可以设置标签和分类并显示了。</p>]]></content>
      
      
      <categories>
          
          <category> errors </category>
          
      </categories>
      
      
        <tags>
            
            <tag> errors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络连接错误解决方案</title>
      <link href="//b9040b7b.html"/>
      <url>//b9040b7b.html</url>
      
        <content type="html"><![CDATA[<h1 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h1><p><strong>fatal: unable to access ‘</strong>无法连接互联网</p><p>需要设置相关代理信息解决问题</p><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><ol><li><strong>检查网络连接</strong>：确保你的计算机正常连接到互联网。尝试在浏览器中打开其他网站，以确保你的网络连接正常。</li><li><strong>防火墙和安全软件</strong>：有时，防火墙或安全软件可能会阻止 Git 与外部服务器建立连接。请检查你的防火墙设置，并确保 Git 被允许通过防火墙。</li><li><strong>代理设置</strong>：如果你在一个受限制的网络环境中，可能需要配置 Git 使用代理服务器。你可以使用以下命令配置 Git 使用代理：</li></ol><pre><code>git config --global http.proxy http://your-proxy-server:portgit config --global https.proxy https://your-proxy-server:port</code></pre><p>将 “your-proxy-server” 和 “port” 替换为你的代理服务器地址和端口号。</p><p>寻找电脑代理信息，点击<strong>设置</strong>，打开里面<strong>代理</strong>，可以看到代理具体信息，如：</p><p><img src="/001.png" alt="image-20231010111358051"></p><p>从中可以得到我的地址和端口，按照要求更改代码即可</p><pre><code># 配置 Git 使用 HTTP 代理git config --global http.proxy http://127.0.0.1:7896</code></pre><p>配置完成后即可正常访问</p>]]></content>
      
      
      <categories>
          
          <category> errors </category>
          
      </categories>
      
      
        <tags>
            
            <tag> errors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习(持续更新中)</title>
      <link href="//caad5a82.html"/>
      <url>//caad5a82.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-前期软件准备"><a href="#一-前期软件准备" class="headerlink" title="一.前期软件准备"></a>一.前期软件准备</h1><h2 id="vs-code安装"><a href="#vs-code安装" class="headerlink" title="vs code安装"></a>vs code安装</h2><p>Google搜索vs code</p><p><img src="/001.png" alt="image-20231008223011703"></p><p>选择第一个直接安装，我这里选择Windows系统</p><h2 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h2><p>Google搜jdk oracle</p><p><img src="/002.png" alt="002"></p><h1 id="第二部分-实现功能"><a href="#第二部分-实现功能" class="headerlink" title="第二部分 实现功能"></a>第二部分 实现功能</h1><h2 id="新建java文件，例如-na-java"><a href="#新建java文件，例如-na-java" class="headerlink" title="新建java文件，例如 na.java"></a>新建java文件，例如 na.java</h2><pre><code class="lang-java">public class na &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;hello java&quot;);    &#125;&#125;</code></pre><h2 id="终端输入下面代码"><a href="#终端输入下面代码" class="headerlink" title="终端输入下面代码"></a>终端输入下面代码</h2><p><code>javac na.java</code></p><p><code>java hello</code></p><p>即可得到输出</p><p>hello java</p><h1 id="第三部分-数据类型"><a href="#第三部分-数据类型" class="headerlink" title="第三部分 数据类型"></a>第三部分 数据类型</h1><h2 id="注解-给人看的文字"><a href="#注解-给人看的文字" class="headerlink" title="注解 (给人看的文字)"></a>注解 (给人看的文字)</h2><ul><li><p>单行注解示范：</p><p>// 注解内容</p></li><li><p>多行注解示范:<br>/*</p><pre><code>    第一行注解    第二行注解</code></pre><p>*/</p></li></ul><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><ul><li>整型: byte,short,int,long</li><li>浮点数: float,double</li><li>布林值：boolen</li><li>字元： char</li><li>字串： String<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2>在vscode里面创建DataTypeVarible.java文件，输入以下代码：</li></ul><pre><code class="lang-java">public class DataTypeVariable&#123;    public static void main(String[] args)&#123;        // 在终端中打印各种类型的资料        // 整型 预设为int         System.out.println(3);        System.out.println(120);        // 变量x的使用        int x;        x=3;        System.out.println(x);        x=120;        System.out.println(x);        // 长整型 数字的后面加上l        System.out.println(2000000000L);        // 什么形式，应该对应什么形式，所以应该为long y而不是int y        long y=200000000000L;        System.out.println(y);        // 浮点数，预设为double类型 double        System.out.println(3.14564965);        // 单精度浮点数 数字后面加上 F 只能到小数点后7位数 float        System.out.println(3.141595233F);        // 布林值 boolean        System.out.println(false);        // 字元 char        System.out.println(&#39;a&#39;);        // 字符串 String        System.out.println(&quot;hello 你好呀&quot;);    &#125;&#125;</code></pre><p>终端执行javac DaTaTypeVarible,java进行编译</p><p>终端执行java DataTypeVarible.java运行代码</p><p><img src="/image-20231010094132100.png" alt="image-20231010094132100"></p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prompt设计之调用Internlm模型代码方法（anaconda）</title>
      <link href="//144c4b6.html"/>
      <url>//144c4b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="internlm大模型基本知识"><a href="#internlm大模型基本知识" class="headerlink" title="internlm大模型基本知识"></a>internlm大模型基本知识</h1><blockquote><p>InternLM 是一个开源的轻量级训练框架，旨在支持大模型训练而无需大量的依赖。通过单一的代码库，它支持在拥有数千个 GPU 的大型集群上进行预训练，并在单个 GPU 上进行微调，同时实现了卓越的性能优化。在1024个 GPU 上训练时，InternLM 可以实现近90%的加速效率。</p></blockquote><p>主要思路是通过魔搭社区对应模型访问，实现本地设计prompt的功能，实现效果展示：</p><p><img src="/001.png" alt="image-20231024213226863"></p><h2 id="利用魔搭社区现有的交互界面"><a href="#利用魔搭社区现有的交互界面" class="headerlink" title="利用魔搭社区现有的交互界面"></a>利用魔搭社区现有的交互界面</h2><p>打开浏览器搜索魔搭社区或者利用网址<a href="https://modelscope.cn/search?search=internlm进入，在搜索框搜索`nternlm`，然后点击模型进入，如下：">https://modelscope.cn/search?search=internlm进入，在搜索框搜索`nternlm`，然后点击模型进入，如下：</a></p><p><img src="/002.png" alt="image-20231024211639103"></p><p>进入交互界面后的图形如下：</p><p><img src="/003.png" alt="image-20231024212306225"></p><p>在这里你可以实现和模型在线聊天功能，如果要实现代码功能需要点击红色框框部分<code>use via api</code></p><p><img src="/004.png" alt="image-20231024212547393"></p><p>这样就能得到api的调用地址<a href="https://modelscope.cn/api/v1/studio/AI-ModelScope/Internlm-chat-7b/gradio/">https://modelscope.cn/api/v1/studio/AI-ModelScope/Internlm-chat-7b/gradio/</a>  </p><h1 id="通过anaconda实现本地访问大模型"><a href="#通过anaconda实现本地访问大模型" class="headerlink" title="通过anaconda实现本地访问大模型"></a>通过anaconda实现本地访问大模型</h1><h2 id="安装python相关库"><a href="#安装python相关库" class="headerlink" title="安装python相关库"></a>安装python相关库</h2><p>在<code>anaconda prompt</code>里面执行以下命令：<br><code>pip install gradio_client</code></p><p>安装执行时所需依赖</p><p>建议先创建python虚拟环境，创建和运行：</p><pre><code>conda create -n xx python ==3.11 #创建python虚拟环境xx,python版本设置为3.11conda activate xx    # 激活python虚拟环境xx</code></pre><h2 id="在anaconda的jupyter实现代码"><a href="#在anaconda的jupyter实现代码" class="headerlink" title="在anaconda的jupyter实现代码"></a>在anaconda的jupyter实现代码</h2><p>需要新建<code>gradio_client.ipynb</code>（对名字可能有严格要求）的源文件，然后在jupyter里面打开该文件</p><p><img src="/005.png" alt="image-20231024213027913"></p><h3 id="导入所用依赖"><a href="#导入所用依赖" class="headerlink" title="导入所用依赖"></a>导入所用依赖</h3><p><code>from gradio_client import Client</code></p><p><code>import json</code></p><h3 id="函数初始化"><a href="#函数初始化" class="headerlink" title="函数初始化"></a>函数初始化</h3><p>定义一个名字为call<em>internlm_chat7b函数，用来完成模型的调用，模型输入为input</em>，输出为模型对于输入的输出</p><pre><code class="lang-python">def call_internlm_chat7b(input_):    &quot;&quot;&quot;    input_: 当前输入    return: 当前输出    &quot;&quot;&quot;    client = Client(&quot;https://modelscope.cn/api/vl/studio/AI-ModelScope/Internlm-chat-7b/gradio/&quot;)    result = client.predict(input_,fn_index=0)    with open(result[1],&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:        data = json.load(f)    return data[-1][-1]  # 返回data变量的最后一个元素的最后一个元素</code></pre><h2 id="初步体验"><a href="#初步体验" class="headerlink" title="初步体验"></a>初步体验</h2><p><code>call_internlm_chat7b(&#39;你好&#39;)</code></p><p><img src="/006.png" alt="image-20231006173411953"></p><p>这样你就可以设计属于自己的prompt了</p><p>完整代码如下：</p><pre><code>from gradio_client import Clientimport jsondef call_internlm_chat7b(input_):    &quot;&quot;&quot;    input_: 当前输入    return: 当前输出    &quot;&quot;&quot;    client = Client(&quot;https://modelscope.cn/api/v1/studio/AI-ModelScope/Internlm-chat-7b/gradio/&quot;)    result = client.predict(input_, fn_index=0)    with open(result[1], &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:        data = json.load(f)    return data[-1][-1]# 使用函数与ChatGLM6B模型进行交互response = call_internlm_chat7b(&quot;你好&quot;)print(response)</code></pre>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internlm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python算法题</title>
      <link href="//5a29c23b.html"/>
      <url>//5a29c23b.html</url>
      
        <content type="html"><![CDATA[<p>题目：算法题，使用你会的编程语言编程即可）小A和朋友们比身高，一共有 𝒏个朋友，每个朋友的身高是 𝒉，小A的身高为 𝑯，一共有 𝒎阶楼梯，第 𝒊阶楼梯的高度是 𝒔𝒊，第 𝒊个朋友会站在第 𝒑𝒊阶楼梯上，小A想知道，如果小A可以自由选择站在第几阶楼梯上，他最多可以比多少朋友高。 输入描述： 一行三个整数 𝑛，𝑚，𝐻，表示朋友的个数，楼梯的个数，小A的身高。 一行 𝑛个整数 ℎ𝑖，表示每个朋友的身高。 一行 𝑛个整数 𝑝𝑖，表示每个朋友站在第几阶楼梯上。 一行 𝑚个整数 𝑠𝑖，表示每个楼梯的高度。 1 ≤𝑛,𝑚≤10^5 1 ≤ 𝐻,ℎ𝑖,𝑠𝑖≤10^6 1≤𝑝𝑖≤𝑚 输出描述： 输出一个整数，表示小A可以比多少朋友高。<br>[示例]<br>输入：<br>3 4 4<br>3 5 7<br>1 2 2<br>1 2 3 3<br>输出：<br>1<br>说明：小A站在最高的楼梯上，高度为 4 + 3 = 7。第一个朋友高度为 3+1=4，第二个朋友高度为 5+2=7，第三个朋友高度为 7+2 =9。<br>小A只能比第一个朋友高 ﻿</p><pre><code>`\# 读取输入n, m, H = map(int, input().split())\# 检查条件if not (1 &lt;= n &lt;= 10**5 and 1 &lt;= m &lt;= 10**5 and 1 &lt;= H &lt;= 10**6):    print(&quot;输入数据不符合条件&quot;)    exit()friend_heights = list(map(int, input().split()))  # 每个朋友的身高ℎ𝑖friend_stairs = list(map(int, input().split()))   # 每个朋友站在的楼梯编号 𝒑𝒊stairs_heights = list(map(int, input().split()))  # 每个楼梯的高度si\# 检查条件if not (all(1 &lt;= hi &lt;= 10**6 for hi in friend_heights) and        all(1 &lt;= si &lt;= m for si in friend_stairs) and        all(1 &lt;= si &lt;= 10**6 for si in stairs_heights)):    print(&quot;输入数据不符合条件&quot;)    exit()\# 计算每个朋友站在不同楼梯上时的身高friend_actual_heights = [friend_heights[i] + stairs_heights[friend_stairs[i] - 1] for i in range(n)]\# 初始化计数器count = 0\# 遍历每个楼梯，计算小A站在不同楼梯上时最多可以比多少个朋友高for i in range(m):    current_height = H + stairs_heights[i]  # 小A站在当前楼梯上的身高    friends_higher = sum(1 for j in range(n) if current_height &gt; friend_actual_heights[j])  # 计算小A站在当前楼梯上能比多少个朋友高    count = max(count, friends_higher)  # 更新最多可以比多少个朋友高\# 输出结果print(count)`</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt的提示工程</title>
      <link href="//b6557c71.html"/>
      <url>//b6557c71.html</url>
      
        <content type="html"><![CDATA[<h1 id="prompt工程"><a href="#prompt工程" class="headerlink" title="prompt工程"></a>prompt工程</h1><h2 id="什么是-Prompt-工程？"><a href="#什么是-Prompt-工程？" class="headerlink" title="什么是 Prompt 工程？"></a>什么是 Prompt 工程？</h2><p>Prompt 工程是创建提示或指导像 ChatGPT 这样的语言模型输出的过程。它允许用户控制模型的输出并生成符合其特定需求的文本。</p><p>ChatGPT 是一种先进的语言模型，能够生成类似于人类的文本。它建立在 Transformer 架构上，可以处理大量数据并生成高质量的文本。</p><p>然而，为了从 ChatGPT 中获得最佳结果，重要的是要了解如何正确地提示模型。 提示可以让用户控制模型的输出并生成相关、准确和高质量的文本。 在使用 ChatGPT 时，了解它的能力和限制非常重要。</p><p>该模型能够生成类似于人类的文本，但如果没有适当的指导，它可能无法始终产生期望的输出。</p><p>这就是 Prompt 工程的作用，通过提供清晰而具体的指令，您可以引导模型的输出并确保其相关。</p><p><strong>Prompt 公式是提示的特定格式，通常由三个主要元素组成：</strong></p><blockquote><ul><li><p>任务：对提示要求模型生成的内容进行清晰而简洁的陈述。</p></li><li><p>指令：在生成文本时模型应遵循的指令。</p></li><li><p>角色：模型在生成文本时应扮演的角色。</p></li></ul></blockquote><h1 id="提示原则"><a href="#提示原则" class="headerlink" title="提示原则"></a>提示原则</h1><p>如何去使用 Prompt，以充分发挥 LLM 的性能？首先我们需要知道设计 Prompt 的原则，它们是每一个</p><p>开发者设计 Prompt 所必须知道的基础概念。设计高效 Prompt 的两个关键原则：<strong>编写清晰、具体的指令</strong>和<strong>给予模型充足思考时间</strong>。掌握这两点，对创建可靠的语言模型交互尤为重要。</p><p>首先，Prompt 需要清晰明确地表达需求，提供充足上下文，使语言模型准确理解我们的意图，就像向一个外星人详细解释人类世界一样。过于简略的 Prompt 往往使模型难以把握所要完成的具体任务。</p><p>其次，让语言模型有充足时间推理也极为关键。就像人类解题一样，匆忙得出的结论多有失误。因此Prompt 应加入逐步推理的要求，给模型留出充分思考时间，这样生成的结果才更准确可靠。</p><p>如果 Prompt 在这两点上都作了优化，语言模型就能够尽可能发挥潜力，完成复杂的推理和生成任务。</p><p>掌握这些 Prompt 设计原则，是开发者取得语言模型应用成功的重要一步。</p><h2 id="原则一-编写清晰、具体的指令"><a href="#原则一-编写清晰、具体的指令" class="headerlink" title="原则一 编写清晰、具体的指令"></a>原则一 编写清晰、具体的指令</h2><h3 id="使用分隔符清晰地表示输入的不同部分"><a href="#使用分隔符清晰地表示输入的不同部分" class="headerlink" title="使用分隔符清晰地表示输入的不同部分"></a>使用分隔符清晰地表示输入的不同部分</h3><blockquote><p>在编写 Prompt 时，我们可以使用各种标点符号作为“分隔符”，将不同的文本部分区分开来。</p></blockquote><p>分隔符就像是 Prompt 中的墙，将不同的指令、上下文、输入隔开，避免意外的混淆。你可以选择用</p><p><code>\```，&quot;&quot;&quot;，&lt; &gt;，&lt;tag&gt; &lt;/tag&gt;，: 等做分隔符，只要能明确起到隔断作用即可。</code></p><p>使用分隔符尤其重要的是可以防止 <strong>提示词注入（**</strong>Prompt Rejection<strong>**）</strong>。什么是提示词注入？就是用户</p><p>输入的文本可能包含与你的预设 Prompt 相冲突的内容，如果不加分隔，这些输入就可能“注入”并操纵语</p><p>言模型，导致模型产生毫无关联的乱七八糟的输出。</p><p>示例如下：</p><pre><code>from tool import get_completiontext = f&quot;&quot;&quot;您应该提供尽可能清晰、具体的指示，以表达您希望模型执行的任务。\这将引导模型朝向所需的输出，并降低收到无关或不正确响应的可能性。\不要将写清晰的提示词与写简短的提示词混淆。\在许多情况下，更长的提示词可以为模型提供更多的清晰度和上下文信息，从而导致更详细和相关的输出。&quot;&quot;&quot;\# 需要总结的文本内容prompt = f&quot;&quot;&quot;把用三个反引号括起来的文本总结成一句话。\```&#123;text&#125;</code></pre><p>“””</p><p># 指令内容，使用 ``` 来分隔指令和待总结的内容</p><p>response = get_completion(prompt)</p><p>print(response)</p><pre><code>输出结果如下：</code></pre><p>为了获得所需的输出，您应该提供清晰、具体的指示，避免与简短的提示词混淆，并使用更长的提示词来提供更</p><p>多的清晰度和上下文信息。</p><pre><code>### 增加背景信息（context）&gt; 包含外部信息或者额外的上下文信息，引导语言模型更好的响应，背景信息包含大模型本身和用户的信息二个部分==如：我是一个小学生，你是苏格拉底==`tips`:角色扮演，给模型一个角色让他按照角色进行输出## 原则二 寻求结构化的输出&gt; 要求模型给出结构化的输出可以提高准确率有时候我们需要语言模型给我们一些**结构化的输出**，而不仅仅是连续的文本。什么是结构化输出呢？就是按照某种格式组织的内容，例如JSON、HTML等。这种输出非常适合在代码中进一步解析和处理。例如，您可以在 Python 中将其读入字典或列表中。==如：50字，4句话；以json，html格式输出，或者直接给出输出的结构样式，让模型按照该结构输出==在以下示例中，我们要求 GPT 生成三本书的标题、作者和类别，并要求 GPT 以 JSON 的格式返回给我们，为便于解析，我们指定了 Json 的键。</code></pre><p>prompt = f”””<br>请生成包括书名、作者和类别的三本虚构的、非真实存在的中文书籍清单，\<br>并以 JSON 格式提供，其中包含以下键:book_id、title、author、genre。<br>“””<br>response = get_completion(prompt)<br>print(response)</p><pre><code>**输出结果**:</code></pre><p>{<br>“books”: [<br>{<br>“book_id”: 1,<br>“title”: “迷失的时光”,<br>“author”: “张三”,<br>“genre”: “科幻”<br>},<br>{<br>“book_id”: 2,<br>“title”: “幻境之门”,<br>“author”: “李四”,<br>“genre”: “奇幻”<br>},<br>{<br>“book_id”: 3,<br>“title”: “虚拟现实”,<br>“author”: “王五”,<br>“genre”: “科幻”<br>}<br>]<br>}</p><pre><code># 原则三 要求模型检查是满足条件&gt; 如果任务包含不一定能满足的假设（条件），我们可以告诉模型先检查这些假设，如果不满足，则会指&gt;&gt; 出并停止执行后续的完整流程。您还可以考虑可能出现的边缘情况及模型的应对，以避免意外的结果或&gt;&gt; 错误发生在如下示例中，我们将分别给模型两段文本，分别是制作茶的步骤以及一段没有明确步骤的文本。我们将要求模型判断其是否包含一系列指令，如果包含则按照给定格式重新编写指令，不包含则回答“未提供步骤”。</code></pre><h1 id="满足条件的输入（text中提供了步骤）"><a href="#满足条件的输入（text中提供了步骤）" class="headerlink" title="满足条件的输入（text中提供了步骤）"></a>满足条件的输入（text中提供了步骤）</h1><p>text_1 = f”””<br>泡一杯茶很容易。首先，需要把水烧开。\<br>在等待期间，拿一个杯子并把茶包放进去。\<br>一旦水足够热，就把它倒在茶包上。\<br>等待一会儿，让茶叶浸泡。几分钟后，取出茶包。\<br>如果您愿意，可以加一些糖或牛奶调味。\<br>就这样，您可以享受一杯美味的茶了。<br>“””<br>prompt = f”””<br>您将获得由三个引号括起来的文本。\<br>如果它包含一系列的指令，则需要按照以下格式重新编写这些指令：<br>第一步 - …<br>第二步 - …<br>…<br>第N步 - …<br>如果文本中不包含一系列的指令，则直接写“未提供步骤”。”<br>\”\”\”{text_1}\”\”\”<br>“””<br>response = get_completion(prompt)<br>print(“Text 1 的总结:”)<br>print(response)</p><pre><code>结果如下：</code></pre><p>Text 1 的总结:<br>第一步 - 把水烧开。<br>第二步 - 拿一个杯子并把茶包放进去。<br>第三步 - 把烧开的水倒在茶包上。<br>第四步 - 等待几分钟，让茶叶浸泡。<br>第五步 - 取出茶包。<br>第六步 - 如果需要，加入糖或牛奶调味。<br>第七步 - 就这样，您可以享受一杯美味的茶了。<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
          <category> llm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prompt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文生图</title>
      <link href="//d0da01c.html"/>
      <url>//d0da01c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、AI-绘画入门"><a href="#一、AI-绘画入门" class="headerlink" title="一、AI 绘画入门"></a>一、AI 绘画入门</h1><h2 id="1、Stable-Diffusion-VS-MidJourney"><a href="#1、Stable-Diffusion-VS-MidJourney" class="headerlink" title="1、Stable Diffusion VS. MidJourney"></a>1、Stable Diffusion VS. MidJourney</h2><p><strong>Midjourney</strong> </p><p>优点:</p><ul><li>操作简单、出图绚丽多彩</li></ul><p>缺点:</p><ul><li><p>订阅付费充钱</p></li><li><p>内容有限制，比如说不能出现暴力和颜色的内容</p></li><li><p>出图还是带有很大的随机性</p></li></ul><p><strong>Stable Diffusion</strong> </p><p>特点:</p><ul><li><p>第一、Stable Diffusion开源</p></li><li><p>第二、可以在本地部署</p></li><li><p>第三、可以安装各种插件，安装插件顾名思义就是如虎添翼</p></li><li><p>第四、内容无限制</p></li></ul><h2 id="2、Stable-Diffusion-介绍"><a href="#2、Stable-Diffusion-介绍" class="headerlink" title="2、Stable Diffusion 介绍"></a>2、Stable Diffusion 介绍</h2><p>目前，随着AI技术的快速迭代，各种基于AIGC（人工智能内容生成）技术的产品不断涌向社会，而其中最普遍的，则莫过于大量的AI绘图模型，如Midjourney、Dreambooth、Novel AI和Stable Diffusion等。</p><p>虽然AI绘图领域，看似进入了百花齐放的时代，但目前业内的顶流，仍然是Midjourney和Stable Diffusion为代表两大龙头。</p><p><strong>Stable Diffusion 维基百科</strong></p><p><a href="https://zh.wikipedia.org/zh-hans/Stable_Diffusion">https://zh.wikipedia.org/zh-hans/Stable_Diffusion</a></p><h2 id="3、Stable-Diffusion-环境搭建"><a href="#3、Stable-Diffusion-环境搭建" class="headerlink" title="3、Stable Diffusion 环境搭建"></a>3、Stable Diffusion 环境搭建</h2><ul><li><p><strong>参考 Github 项目：stable-diffusion-webui</strong></p></li><li><p><strong>启动命令：</strong></p></li></ul><pre><code class="lang-shell">$ ./webui.sh --precision full --no-half</code></pre><ul><li><strong>汉化：</strong></li></ul><p>通过安装语言包和配置扩展实现。</p><ul><li><strong>模型下载网站：</strong></li></ul><p><a href="https://civitai.com/">https://civitai.com/</a></p><p><a href="https://huggingface.co">https://huggingface.co</a></p><h2 id="4、文生图与图生图"><a href="#4、文生图与图生图" class="headerlink" title="4、文生图与图生图"></a>4、文生图与图生图</h2><p>文生图 （Text to Image）</p><ul><li>需要提示词，画面控制主要靠提示词</li></ul><p>图生图（Image to Image）</p><ul><li>需要提示词，图片辅助提示词进行画面控制</li></ul><h1 id="二、文生图入门与提示词基础"><a href="#二、文生图入门与提示词基础" class="headerlink" title="二、文生图入门与提示词基础"></a>二、文生图入门与提示词基础</h1><p>AI绘画和魔法、念咒有什么关系？记得吗，作图过程中，有一个必不可少的环节，就是向AI输入用于描述画面的Prompt，在AI聊天里我们也用。因为大部分AI绘制作品的提示词是用英文写的，很长，很乱。而且穿插着各种奇怪的数字、符号，就像高深莫测的咒语一样。因此，大家形象的把这个书写提示词的过程称为“念咒”。而我们，就像那些魔法师一样，要通过吟唱咒语，来变出我们想要的结果。虽说AI是人工智能，但它和真正意义上的人类智慧还是有一定差距的，很多时候它并不知道你想要的是什么。因此，就需要详尽的提示词来帮助你更好地指挥AI作图。这也是为什么，“念咒”这件事，在AI绘画盛行的今天，已经慢慢形成了一门独特的可以去探讨、研究的学问。</p><p>本课程讲解的内容使用的是Stable Diffusion，但我知道有很多朋友用的是另一款非常流行的AI绘画应用MidJourney，这些框架的大逻辑框架其实是通用的，而 MidJourney 比SD要更依赖好的提示词来做出作品，在提示词的应用层面更具深度。</p><h2 id="1、提示词基本概念"><a href="#1、提示词基本概念" class="headerlink" title="1、提示词基本概念"></a>1、提示词基本概念</h2><blockquote><p>内容概要：</p><ul><li>提示词的概念和基本逻辑</li><li>提示词的语法（输入、间隔）</li><li>内容型提示词与标准化提示词</li></ul></blockquote><p>这节课，我们来接触StableDiffusion中的文生图功能，也就是经由文本生成图像，这里面的“文”，指的自然就是提示词Prompt了。广义的解释，Prompt是指用户输入的文本或者图像信息，目的是指导模型根据一些特定的需求生成艺术作品。直白一点说，它是我们用来告诉AI“我要画什么”，“画成什么样”的一种语言。</p><p>上节课里，我们也提过了，SD里进行绘制的两种基本方式，文生图和图生图，文生图就是主要以文字来实现这个沟通过程的，而图生图还可以依赖图片来传达信息，但图生图里也有提示词，而且同样重要。提示词包括的内容，也是非常广泛的，它可能包括作品主题、画风、形象特点以及一些具体包含的要素。</p><p>比如以下例子：</p><pre><code>正面提示词：(1girl:2.0), solo, nilou \(genshin impact\), solo, long hair, jewelry, blue gemstone, earrings, horns, crown, cyan satin strapless dress, white veil, neck ring, red hair, &#123;green eyes&#125;, ((full body)), (SFW:1.5), front, highly detailed face, curvy body, skindentation, hands up, happy smily face, pureerosface_v1, hiqcgbody,&#123;&#123;masterpiece&#125;&#125;, &#123;best quality&#125;,&#123;highresl&#125;, original, reflection,Exaggerated body proportions, greasy skin, realistic and delicate facial features, depth of field, extremely detailed CG unity 8k wallpaper, bloom, shine, (illustration), (painting), (sketch), anime coloring, fantasy, unreal engine, body shadow, artstationindoor, sitting on sofa, sunset, backlighting, shiny skin, lens flare, light particles, glowing, dappled sunlight, extreme shadow and light, long shadow, light rays, sunwind blow, maple leaf, cloudy sky, dusty, forest, plant, flower反面提示词：EasyNegative, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)),((grayscale)),skin spots, acnes, skin blemishes, age spot, (outdoor:1.6), (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21)(tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.33), (more than 2 nipples:1.331), (missing arms:1.33), (extra legs:1.331), (fused fingers:1.61051),(too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit, (futa:1.1), bad hands, missing fingers, (((extra arms and legs))), extra hair, (2girls:2.0), signature, watermark, username, atist name</code></pre><p><img src="/001.png" alt="00000-446021579"></p><p><img src="/002.png" alt="00003-2149389212"></p><p>不同的提示词分别向AI描绘了画面风格、人物体貌、服饰特点、场景内容和一些额外的修饰性元素。别看这么多的字，其实，很多关于风格和画质把控的提示词是固定的。</p><p>虽然说提示词并非越多越好，但很多时候写多点，比少写点出来的效果肯定要更好，且在特定需求上控制会更为精确。所以，要想让AI按照我们的需要去产图，提示词到底该怎么写呢？放轻松，其实写提示词的过程非常自由的，无论你写什么，AI都可以给你画，在StableDiffusion中，可以输入提示词的区域就是左上方这两个文本框了，之前也提到了，它被分为了上下两部分，上面是正向的提示词，下面是反向的提示词。虽然自由，但提示词有一些基本的语法规则，是你应该掌握的。</p><p>首先，提示词需要英文书写，所以，如果你英语水平足够好，可以用英语组织你的描述语言，如果不好，可以求助翻译软件。</p><p>其次，提示词是以词组作为单位的，它不需要像真的英语句子一样，有完整的语法结构主从句之类的东西。就像你如果跟AI说：“画一个又长又宽的面和一个又大又圆的碗”，那直接可以分解成(面, 长, 宽), (碗, 大, 圆)，这样AI也能听懂，甚至有时候听的比前一种更懂。</p><p>词组与词组之间，需要插入分隔符，基本的分隔符形式是一个英文里的半角逗号。再输入提示词的时候，最好把输入法切换到英文。因为里面涉及的符号基本都是英文的，提示词可以换行，但每一行的行末最好也打上分隔符。</p><pre><code>1girl, walking, forest, path, sun, sunshine</code></pre><pre><code>1girl, walking, forest, path, sun, sunshine,shining on body,</code></pre><p>在输入这些东西以后，点击“Generate”，生成图画，出来的图片是这样的：</p><p><img src="/003.png" alt="00006-1663017696"></p><p>它有可能符合你的需要，也有可能变得奇奇怪怪。AI绘画是具有一定的随机性的，点多几次生成，每次生成出来的东西都会不太一样。之前，也有人把AI绘画比喻为“抽卡”，想出好的图片，得靠运气来抽。“一个女孩在林中漫步”，这其实只是一个非常概括的描述，这个女孩长什么样子、森林里有什么东西，时间是早上还是晚上、天气如何，这些东西，AI都不知道，你的提示词太过于笼统，那它就只能瞎蒙抽卡了。但也别担心，提示词很多时候不是一下子就写好的，而是现有一个雏形，再慢慢细化、补充和微调的。</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, looking at viewer, close-up, upper body,(masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting, (extremely detailed CG:1.2), drawing, paintbrush</code></pre><p>还可以加一些的提示词，更多的就是在一些具体的方面，对这个画面去做控制。</p><p><img src="/004.png" alt="00007-2658747475"></p><h2 id="2、提示词分类和书写方式"><a href="#2、提示词分类和书写方式" class="headerlink" title="2、提示词分类和书写方式"></a>2、提示词分类和书写方式</h2><p>要加些什么呢？提示词有很多不同的分类。这里，把提示词概括成如下几个大类。</p><h3 id="1-人物及主题特征"><a href="#1-人物及主题特征" class="headerlink" title="(1) 人物及主题特征"></a>(1) 人物及主题特征</h3><ul><li>服饰穿搭：white dress</li><li>发型发色：blonde hair，long hair</li><li>五官特点：small eyes，big mouse</li><li>面部表情：smiling</li><li>肢体动作：stretching arms</li></ul><p>比如：女孩，白色连衣裙，金发，长发，微笑，伸展手臂，举手，美丽的，快乐的</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,</code></pre><p><img src="/005.png" alt="00000-1611124299"></p><h3 id="2-场景特征"><a href="#2-场景特征" class="headerlink" title="(2) 场景特征"></a>(2) 场景特征</h3><ul><li>室内、室外：indoor/outdoor</li><li>大场景：forest, city, street</li><li>小细节：tree, bush, white flower</li></ul><p>比如：树木，灌木，白色的花，（林间）小路</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,trees, bush, white flower, outdoor,</code></pre><h3 id="3-环境光照"><a href="#3-环境光照" class="headerlink" title="(3) 环境光照"></a>(3) 环境光照</h3><ul><li>白天、黑夜：day / night</li><li>特定时段：morning, sunset</li><li>光环境：sunlight,  bright,  dark</li><li>天空：blue sky,  starry sky</li></ul><p>比如：白天、阳光、蓝天、多云的天空</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,trees, bush, white flower, path, outdoor,day, sunlight, blue sky, cloudy sky,</code></pre><h3 id="4-补充：画幅视角"><a href="#4-补充：画幅视角" class="headerlink" title="(4) 补充：画幅视角"></a>(4) 补充：画幅视角</h3><ul><li>距离：close-up(特写)，distant</li><li>人物比例：full body, upper body</li><li>观察视角：from above, view of back</li><li>镜头类型：wide angle, Sony A7</li></ul><p>比如特写：</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,trees, bush, white flower, path, outdoor,day, sunlight, blue sky, cloudy sky, close-up</code></pre><p>可以把这四个分类叫做“内容型提示词”，然而，只有内容型的提示词，你画出的东西很大概率不会让你满意，这里，我们需要引入其他的提示词，来给这个画面打一剂强心针。</p><p>首先是画质，因为在AI学习的图片里，有些是高清的，有些质量比较模糊，我们可以用这样的提示词，让他盯着哪些高清的去看。</p><h3 id="5-画质提示词"><a href="#5-画质提示词" class="headerlink" title="(5) 画质提示词"></a>(5) 画质提示词</h3><ul><li>通用高画质：best quality, ultra-detailed, masterpiece, hires, 8k</li><li>特定高分辨率类型：extremely detailed CG unity 8k wallpaper(超精细的8K Unity游戏CG), unreal engine rendered(虚幻引擎渲染)</li></ul><p>比如：最高的质量，超级细节，杰作，高分辨率，8K(分辨率)，超细节的Unity CG壁纸</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,trees, bush, white flower, path, outdoor,day, sunlight, blue sky, cloudy sky, close-up,best quality, ultra-detailed, masterpiece, hires, 8k,extremely detailed CG unity 8k wallpaper, unreal engine rendered</code></pre><h3 id="6-画风提示词"><a href="#6-画风提示词" class="headerlink" title="(6) 画风提示词"></a>(6) 画风提示词</h3><ul><li>插画风：illustration, painting, praintbrush</li><li>二次元：anime, comic, game CG</li><li>写实系：photorealistic, realistic, photograph</li></ul><p>比如：绘画，插画，动画，游戏CG</p><pre><code>1girl, walking, forest, path, sun, sunshine, shining on body, white dress, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy,trees, bush, white flower, path, outdoor,day, sunlight, blue sky, cloudy sky, close-up,best quality, ultra-detailed, masterpiece, hires, 8k,extremely detailed CG unity 8k wallpaper, unreal engine renderedpainting, illustration, anime, game CG</code></pre><p>（5）、（6）可以称为标准化的提示词。</p><h3 id="7-提示词模板"><a href="#7-提示词模板" class="headerlink" title="(7) 提示词模板"></a>(7) 提示词模板</h3><pre><code>描述人物:(1girl:2.0), solo, nilou \(genshin impact\), solo, long hair, jewelry, blue gemstone, earrings,horns, crown, cyan satin strapless dress, white veil, neck ring, red hair, &#123;green eyes&#125;,描述场景:indoor, room, house, sofa, wooden floor, plant, flowers, trees, windows,描述环境(时间、光照):day, morning, sunlight, dappled sunlight, backlight, light rays, cloudy sky描述画幅视角:full body, wide angle shot, depth of field其他画面要素:light particles, fantasy, wind blow, maple leaf, dusty,... (其他往后增加)高品质标准化:&#123;&#123;masterpiece&#125;&#125;, &#123;best quality&#125;, &#123;highres&#125;, original, reflection, unreal engine, body shadow, artstationextremely detailed CG unity 8k wallpaper画风标准化:(illustration), (painting), (sketch), anime coloring, fantasy,其他特殊要求:exaggerated body proportions, greasy skin, realistic and delicate facial features, SFW</code></pre><h2 id="3、权重与负面提示词"><a href="#3、权重与负面提示词" class="headerlink" title="3、权重与负面提示词"></a>3、权重与负面提示词</h2><h3 id="1-提示词的权重"><a href="#1-提示词的权重" class="headerlink" title="(1) 提示词的权重"></a>(1) 提示词的权重</h3><p>如下咒语，</p><pre><code>SFW, 1girl, walking, forest, path, sun, sunshine, shining on body,yellow skirt and white t-shirt, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy.trees, bush, white flower, path, outdoor,(masterpiece:1.2) , best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting(extremely detailed CG:1.2), drawing, paintbrush.</code></pre><p>你会看到很多(),小数点，逗号之类的符号和数字，他们又是做什么的呢？其实，这些内容是用来增强或者是减弱某些提示词的优先级和权重的，比如刚才我们看到这个画面，我们输入了 <code>white flower</code>, 但我们在图片上并没有清晰的看到白色的花，你输入了很多不同的元素给AI，都要他画，但他在处理的时候，不一定get到你最想要的是什么，所以有可能优先花了树和森林，如果你就是特别特别想要百花，那就可以用类似的方式，把白花的权重和优先级增强，去增强的方式有两种：</p><ul><li><p>套括号</p><p><code>()</code> 会使权重变为 1.1 倍，相对于其他元素就更突出。你还可以套多层括号，每套一层，就再乘以1.1倍，三层就是1.331倍。这样花就出来了：</p><pre><code>SFW, 1girl, walking, forest, path, sun, sunshine, shining on body,yellow skirt and white t-shirt, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy.trees, bush, (((white flower))), path, outdoor,(masterpiece:1,2) , best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting(extremely detailed CG:1.2), drawing, paintbrush.</code></pre></li></ul><ul><li><p>括号加数字权重</p><p>加了一种括号以后，可以在后面加一个英文冒号，后面可以接一个数字。</p><pre><code>SFW, 1girl, walking, forest, path, sun, sunshine, shining on body,yellow skirt and white t-shirt, blonde hair, long hair, smiling, stretching arms, hands up, beautiful, happy.trees, bush, (white flower: 1.5), path, outdoor,(masterpiece:1,2) , best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting(extremely detailed CG:1.2), drawing, paintbrush.</code></pre><p>所以，当你觉得这个画面里有你告诉了AI但他又没有画出来的东西时，就可以借助这些方法来强调。加数字的方式明显更准确，而加括号进行微调的时候就更方便。</p><p>比起圆括号，还有这种大括号 <code>&#123;&#125;</code>, 代表1.05倍，调节的效果就细微一点。</p></li><li><p>削弱提示词</p><p>而如果你想削弱某个提示词的影响，就可以赋予它一个小于 1 的权重数值，或者用方括号<code>[]</code>, 会把原来的权重削弱成原来的 0.9 倍。调节权重的时候，也要注意一件事情，就是尽量避免个别词条的权重太高，我体验的安全范围在 1 上下 0.5 左右。当你赋予一个词条2左右甚至更高的数值时，他就容易扭曲画面的内容。这个时候我们通常要改换思路。通过更多类型的词条来协助增强它的效应。</p></li></ul><p><strong>总结一下：</strong></p><p><img src="/006.png" alt="image-20230801063233335"></p><ul><li>进阶语法</li></ul><p><img src="/007.png" alt="image-20230801063519417"></p><h3 id="2-负面提示词"><a href="#2-负面提示词" class="headerlink" title="(2) 负面提示词"></a>(2) 负面提示词</h3><p>提示词另外一个构成部分，是负面提示词。通俗点说，你希望这个画面里出现什么，就往正向提示词里丢，而不希望出现什么，就往反向提示词里丢。反向提示词是可以没有的，但一般我们也会选择加入一些通用的项目，主要也是基于标准化的考虑，比如：</p><pre><code>NSFW, (worst quality:2) , (low quality:2), (normal quality:2) , lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, (((extra arms and legs))),</code></pre><h3 id="3-出图参数详解"><a href="#3-出图参数详解" class="headerlink" title="(3) 出图参数详解"></a>(3) 出图参数详解</h3><p>如果说提示词是咒语，那出图参数就像是魔法师的魔杖和魔导书一样，空着了这个咒语的具体释放形式。</p><ul><li><p><strong>采样迭代步数</strong></p><p>AI 生成图像会经过一个加噪再去噪的过程，而去噪就是在用像素一点点模拟你的最终要生成的这个图像，每模拟一次，画面就会变得更清晰一点。理论上，采样迭代步数越多，肯定最终效果越清晰，但实际上，当步数大于20步以后，后面的提升不大。而增加步数肯定意味着更长的计算时间。所以，默认的采样步数一般都是 20。你算力充足，且想追求更高的清晰度，就设置为 30-40，最低不要低于 10。</p></li><li><p><strong>采样方法</strong></p><p>采样方法，其实可以简单解释成AI进行图像生成的时候使用的某种特定算法，WebUI提供的采样方法非常多，足足十几个，但其中我们常用到的估计也就4-5个。这其中：</p><p>Euler 的两个合适插画风格，出图比较朴素。</p><p>DPM 2 和 DPM2 Karras 速度较快。</p><p>再具体使用时，我推荐使用带有 <code>++</code> 号的，这些都是改进了的算法，无论如何都比上面的更稳定。</p><p>另外，大部分模型也有推荐使用某种特定的算法，这可能是模型制作者自己测试过的。比如深渊橘的作者最推荐用的就是SDE Karras。</p></li><li><p><strong>宽度和高度</strong></p><p>代表的就是你最终出图的时候的分辨率，分辨率的设置存在一些隐性限制，默认的分辨率是 512 x 512，但这个分辨率下的图片，哪怕细节再丰富，看起来都是模糊的。设备允许的情况下，我会把他提到 1000 左右。</p><p>相同的提示词，用更高的分辨率跑出来，质感就完全不一样了。但是，分辨率设置的太高，也是会有问题的，一是你的显卡显存扛不住；其二，则是分辨率太大了，很容易出现多人、多手、多脚的情况。这个问题我有特殊研究过，它的原因是，AI在进行模拟训练的时候，用的图片的分辨率一般都比较小，如果你的分辨率设置太大，它就会认为你是多张图片拼接而成的，那出现多的人就不奇怪了。</p><p>要避免这样的问题出现，一般我们先采用低分辨率绘制，再靠<strong>高清修复(Hires Fix)</strong> 来放大。它本身其实是额外的做了一次图生图。你也可以反复实验，了解在你当前的设备条件下，什么分辨率是既能保证质量又能兼顾效率的。</p></li><li><p>面部修复</p><p>面部修复一般都要勾选上，它会采用一些对抗算法识别人物面部并进行修复，和我们用的美图App里面智能P脸的功能差不多。</p></li><li><p>平铺/分块(Tiling)</p><p>平铺，是用来生成那种可以无缝贴满整个屏幕的纹理性图片的。如果你没有需要，千万别勾，也是一个让你的画面变的很奇怪的东西。</p></li><li><p>提示词相关性（CFG Scale）</p><p>提示词相关性好理解，它的值越高，AI忠实地反映你的提示词的程度就越高，但和权重一样，我们一般不会浮动太多，7-12 是比较安全的数值，太高容易边型。</p></li><li><p>随机种子</p><p>随机种子也是一个可以用来控制画面内容一致性的重要参数。</p></li><li><p>生成批次</p><p>因为AI绘画的不确定性，即便是同一组提示词，你也需要反复试验，期待它在某个瞬间给你一个完美符合你需要的画面，这个时间过程有时会很漫长，可能会经过几十次、上百次。如果你想让AI一直不断地按照同一组提示词和参数去出图，那就把批次数调高，绘制的过程会不断重复进行。</p><p>结束以后，它会生成两样东西——除了每个批次出的图，还会有一张拼在一起的格子预览图，方便你进行对比。所以，你完全可以让它一口气来上个10次20次甚至几百次</p></li><li><p>每批数量</p><p>这个不建议调整，增大可以让你每批次数绘制的图像数量增多。理论上效率会更高，但它同一批绘制的方法是把他们拼接在一起看作一张更大的图片一次去画，所以你的设备不好，非常容易爆显存。</p><h2 id="4、提示词到底怎么写？"><a href="#4、提示词到底怎么写？" class="headerlink" title="4、提示词到底怎么写？"></a>4、提示词到底怎么写？</h2></li></ul><p>对于新手，我给大家总结三个快速写提示词的方法：</p><h3 id="1-翻译大法"><a href="#1-翻译大法" class="headerlink" title="(1) 翻译大法"></a>(1) 翻译大法</h3><p>其实，无论这些提示词再怎么复杂，它们说的还都是人话。因此，当你不不知道该如何表述的时候，就用自然的语言把你想要画的东西一件件地说出来就好了。还是那句话，SD 不认中文，所以你得先用翻译平台把它转成英文。虽然这些词语表述有时候不绝对准确，但它至少是在帮你接近那个你想要的画面。而有一些功能插件也会帮助你把不准确的意象校正成AI的词典里有的东西，也蛮实用的。目前，也有一些开发者做出了很多提示词的插件，大家可以去探索。</p><h3 id="2-借助工具"><a href="#2-借助工具" class="headerlink" title="(2) 借助工具"></a>(2) 借助工具</h3><p>AI 绘画也流行了一段时间了，能意识到提示词难写的人，肯定也不止你我而已。因此，有些人专门开发了一些可以帮助你更好地去书写提示词的工具。</p><p>这里，我推荐两个可以用于辅助书写提示词的网站：</p><p><a href="http://atoolbox.net">http://atoolbox.net</a></p><p><a href="https://ai.dawnmark.cn">https://ai.dawnmark.cn</a></p><p>他们的用法都很简单，你可以像选参数一样，勾选那些你需要的，它会帮助你自动按照刚刚我们说的那些语法规则整理到一起。然后你再复制粘贴到自己的SD里面就可以。使用这些工具，像是在经历一个更方便的翻译的过程。但要注意，思路不要被他已有的一些词汇限制住了。如果有其他你想要加进去的东西，也可以尝试自己撰写添加。</p><h3 id="3-抄作业"><a href="#3-抄作业" class="headerlink" title="(3) 抄作业"></a>(3) 抄作业</h3><p>在AI绘画领域，抄作业并不是什么不光彩的事，有很多创作者还会主动分享自己作图使用的咒语和模型。</p><p><a href="https://civitai.com/">https://civitai.com/</a></p><p><a href="https://openart.ai">https://openart.ai</a></p><p><a href="https://arthub.ai">https://arthub.ai</a></p><h1 id="三、图生图"><a href="#三、图生图" class="headerlink" title="三、图生图"></a>三、图生图</h1><blockquote><p>内容概要：</p><p>1、图生图原理</p><p>2、图生图基本流程</p><p>3、随机种子作用解析</p></blockquote><h2 id="1、图生图原理"><a href="#1、图生图原理" class="headerlink" title="1、图生图原理"></a>1、图生图原理</h2><p>图生图可以帮你把一张图片画成另一种模样。在文生图中我们看到，AI文生图是有一定的随机性的，画出来的东西不一定完全满足我们的需求。在现实生活里，这种对需求的传递偏差与错误解读其实也普遍存在。比如天天干架的产品经理和程序员、甲方客户与设计师。我们和AI之间的交流，可以把一张图片给他作为参考，来生成一张新的图片。</p><h2 id="2、图生图的三个关键步骤"><a href="#2、图生图的三个关键步骤" class="headerlink" title="2、图生图的三个关键步骤"></a>2、图生图的三个关键步骤</h2><ul><li>第一步：导入图片</li><li>第二步：书写提示词</li><li>第三步：参数调整</li></ul><h2 id="3、参数技术性解析"><a href="#3、参数技术性解析" class="headerlink" title="3、参数技术性解析"></a>3、参数技术性解析</h2><p>直接参考文生图的提示题。</p><p><strong>正向提示词：</strong></p><pre><code>(masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, pertect lighting, (extremel detailed CG:1.2), drawing, paintbrush,</code></pre><p><strong>反向提示词：</strong></p><pre><code>NSFW, (worst quality:2) , (low quality:2), (normal quality:2) , lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, (((extra arms and legs))),</code></pre><p><strong>参数设置：</strong></p><ul><li><p>重绘幅度</p><p>表示绘制的图和原图相差的比重。</p></li><li><p>分辨率</p><p>最好和图片比例相同，不然会边型。</p></li></ul><h2 id="4、随机种子的含义研究"><a href="#4、随机种子的含义研究" class="headerlink" title="4、随机种子的含义研究"></a>4、随机种子的含义研究</h2><p>AI生成画面是随机的，但它的每一次生成都有自己的一套描绘方式，而这个描绘方式，就会被记录成一组随机数，这个东西，我们就把它叫做一个随机种子。</p><p>不同的随机种子，出来的效果当然是随机性强的，但如果你使用的是同一个随机种子，那生成的图像里就必然会存在很多的相似之处，因为它是用同一套方法随机出来的。</p><p>从它的视角看，你说AI绘画是抽卡其实基本是正确的，因为你每生成一次，就会得到一个随机种子。有的种子效果好，有的种子效果差。</p><p>在随机种子设置里，有两个功能按钮，点那个骰子，可以把随机参数设置成 -1，就是每次都抽一张新的卡。点那个循环按钮，就会把种子设置成你的上一张卡抽出来的那个数。</p><p>打开图库浏览器，找到我们之前生成的一些图片，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo学习日记(持续更新中)</title>
      <link href="//52e7e92.html"/>
      <url>//52e7e92.html</url>
      
        <content type="html"><![CDATA[<h1 id="部署hexo博客"><a href="#部署hexo博客" class="headerlink" title="部署hexo博客"></a>部署hexo博客</h1><p>首先需要安装<code>hexo-deployer-git</code>插件，这样我们才能把生成的<code>public</code>文件夹部署到Github或者其他代码托管平台。</p><pre><code class="lang-bash">npm install hexo-deployer-git --save</code></pre><p>下面你需要打开根目录，然后在这个目录下找到站点配置文件<code>_config.yml</code>（如下图左）。并且打开这个文件，进行编辑。</p><p><img src="/image-1.png" alt="2"></p><p>在站点配置文件内（如上图右）找到==deploy==这一行代码，按照以下的格式修改即可。</p><pre><code class="lang-bash">deploy:  type: git  repo: git@github.com:damon-ldl/damon-ldl.github.io.git   branch: master</code></pre><ul><li><p>deploy: 部署的意思，一个关键词</p></li><li><p>type：部署的类型，这里选择的是git，就是上面我们已经安装的那个</p></li><li><p>repo：仓库的意思，我们所有的本地文件都要上传到这里！我们要在github上面申请自己的账号，建造自己的仓库~（具体怎么做见后文！）</p></li><li><p>branch：仓库的分支的意思，一个仓库里面可以有多个分支，就像是一个大院里面有很多间厢房一样。具体的含义后面解释。</p></li></ul><h1 id="hexo相关命令"><a href="#hexo相关命令" class="headerlink" title="hexo相关命令"></a>hexo相关命令</h1><h4 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h4><pre><code>$ hexo init</code></pre><p>命令用于初始化一个本地文件夹为网站的根目录</p><h4 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h4><pre><code>$ hexo new title 新建一篇文章$ hexo new page messageboard 出现source/messageboard/index.md文件</code></pre><h4 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a>hexo generate</h4><pre><code>$ hexo generate 可以简写成 hexo g该命令用于生成静态文件</code></pre><h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a>hexo server</h4><pre><code>$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s可以加一些参数-p    选项，指定服务器端口，默认为 4000-i    选项，指定服务器 IP 地址，默认为 0.0.0.0-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</code></pre><h4 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a>hexo deploy</h4><pre><code>$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d</code></pre><h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><pre><code>$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令</code></pre><h4 id="hexo-—safe"><a href="#hexo-—safe" class="headerlink" title="hexo —safe"></a>hexo —safe</h4><pre><code>$ hexo --safe 表示安全模式，用于禁用加载插件和脚本</code></pre><h4 id="hexo-—debug"><a href="#hexo-—debug" class="headerlink" title="hexo —debug"></a>hexo —debug</h4><pre><code>$ hexo --debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</code></pre><h4 id="hexo-—silent"><a href="#hexo-—silent" class="headerlink" title="hexo —silent"></a>hexo —silent</h4><pre><code>$ hexo --silent  表示静默模式，用于静默输出到终端</code></pre><h1 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h1><pre><code>npx hexo cl &amp;&amp;npx hexo g &amp;&amp;npx hexo s</code></pre><ul><li><code>hexo cl</code> 是 <code>hexo clean</code>的简写。意思是清除本地的缓存，实际上就是把博客文件夹下的<code>public</code>文件夹删除掉了。这个<code>public</code>是基于本地的文件生成的、用于上传到仓库或者其他网站服务器上的文件夹，可以理解为本地文件上网的中转站、交通工具，删掉了也不影响本地的内容。</li><li><code>hexo g</code> 是<code>hexo generate</code>的简写，意思是生成public文件夹。</li><li>hexo s 命令用于启动本地服务器</li></ul><pre><code>npx hexo d</code></pre><ul><li><code>hexo d</code>是<code>hexo deploy</code>的简写，意思是将生成的public文件夹部署到网上，我们这里是部署到github上面。</li></ul><h1 id="部署常见错误"><a href="#部署常见错误" class="headerlink" title="部署常见错误"></a>部署常见错误</h1><h2 id="文章标签页设置"><a href="#文章标签页设置" class="headerlink" title="文章标签页设置"></a>文章标签页设置</h2><hr><pre><code>title: 【必需】文章标题date: 【必需】文章创建日期updated: 【可选】文章更新日期tags: 【可选】文章标签categories: 【可选】文章分类keywords: 【可选】文章关键字description: 【可选】文章描述top_img: 【可选】文章顶部图片comments： 【可选】显示文章评论模块 (默认 true)cover: 【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)toc: 【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)toc_number: 【可选】显示 toc_number (默认为设置中 toc 的 number 配置)auto_open: 【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)copyright: 【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)copyright_author: 【可选】文章版权模块的文章作者copyright_author_href: 【可选】文章版权模块的文章作者链接copyright_url: 【可选】文章版权模块的文章连结链接copyright_info: 【可选】文章版权模块的版权声明文字mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置highlight_shrink：【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</code></pre><p>文章标签页设计中一定要注意“：”后面需要<code>空格</code>！！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown学习日志</title>
      <link href="//2339e0f4.html"/>
      <url>//2339e0f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="初始头文件"><a href="#初始头文件" class="headerlink" title="初始头文件"></a>初始头文件</h1><pre><code># Markdown头文件创建例子---title: 【必需】文章标题date: 【必需】文章创建日期updated: 【可选】文章更新日期tags: 【可选】文章标签categories: 【可选】文章分类keywords: 【可选】文章关键字description: 【可选】文章描述top_img: 【可选】文章顶部图片comments： 【可选】显示文章评论模块 (默认 true)cover: 【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)toc: 【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)toc_number: 【可选】显示 toc_number (默认为设置中 toc 的 number 配置)auto_open: 【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)copyright: 【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)copyright_author: 【可选】文章版权模块的文章作者copyright_author_href: 【可选】文章版权模块的文章作者链接copyright_url: 【可选】文章版权模块的文章连结链接copyright_info: 【可选】文章版权模块的版权声明文字mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置highlight_shrink：【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)---</code></pre><hr><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p> 方式一：这个标题手敲就在文本前边敲#号，#和文本中间需又空格隔开。</p><p> 方式二：快捷键，Ctrl+(1~6)。</p><p> 方式三：在Typora文本编辑区右键鼠标，选择段落也可以插入标题。不止标题，还有其他样式设置</p><p> 方式四：在编辑器中左上角的菜单栏选择段落去插入标题。不止标题，还有其他样式设置</p><pre><code>&#39;&#39;&#39;第一种方式&#39;&#39;&#39;   # 一级标题   快捷键Ctrl + 1   # 二级标题   快捷键Ctrl + 2   # 三级标题   快捷键Ctrl + 3&#39;&#39;&#39;第二种方式&#39;&#39;&#39;  #警号（#）数加空格来决定标题大小</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">标题</th><th style="text-align:center">语法（方式一）</th><th>快捷键（方式二）</th></tr></thead><tbody><tr><td style="text-align:center">一级标题</td><td style="text-align:center">#一级标题</td><td>ctrl+1</td></tr><tr><td style="text-align:center">二级标题</td><td style="text-align:center">##二级标题</td><td>ctrl+2</td></tr><tr><td style="text-align:center">三级标题</td><td style="text-align:center">###三级标题</td><td>ctrl+3</td></tr><tr><td style="text-align:center">四级标题</td><td style="text-align:center">####四级标题</td><td>ctrl+4</td></tr><tr><td style="text-align:center">五级标题</td><td style="text-align:center">#####五级标题</td><td>ctrl+5</td></tr><tr><td style="text-align:center">六级标题</td><td style="text-align:center">#######六级标题</td><td>ctrl+6</td></tr></tbody></table></div><p><img src="/1.png" alt="1"></p><p>序号添加:</p><pre><code>    无序标题        星号空格配合文本  * 小标题    有序标题        数字+点+空格+文本  1. 小标题</code></pre><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><div class="table-container"><table><thead><tr><th>字体</th><th>语法（方式一）</th><th>快捷键（方式二）</th></tr></thead><tbody><tr><td>斜体</td><td><em>文本</em></td><td>CTRL+I</td></tr><tr><td>加粗</td><td><strong>文本</strong></td><td>CTRL+B</td></tr><tr><td>下划线</td><td><u>文本</u></td><td>CTRL+U</td></tr><tr><td>删除线</td><td><del>文本</del></td><td>Alt+Shift+5</td></tr><tr><td>高亮</td><td>==文本==</td><td>备注：需勾选高亮设置</td></tr><tr><td>文本居中</td><td><center>文本</center></td><td>无</td></tr><tr><td>文本颜色修改</td><td>$\textcolor{颜色}{文本}$</td><td>备注：需勾选内联公式设置</td></tr></tbody></table></div><p>使用ctrl+/，可切换源代码模式和预览模式</p><p>Ctrl+/</p><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p><img src="/2.png" alt="2"></p><p><img src="/3.png" alt="3"><img src="/4.png" alt="4"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
